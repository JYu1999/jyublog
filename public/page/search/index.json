[{"content":"在寫 Rails 的時候，常常會看到使用 Symbol 的狀況：\nclass User \u0026lt; ApplicationRecord belongs_to :permission belongs_to :department has_secure_password validates :email, presence: true, format: { with: /\\A([^@\\s]+)@((?:[-a-z0-9]+\\.)+[a-z]{2,})\\z/i, message: \u0026#34;must be a valid email address\u0026#34;} end 看了很久還是沒有很習慣這種寫法，所以來寫一篇文章整理一下自己的思緒。\nString Ruby 的 string 後面是預設可以加上一些 method 的，例如：\nname = JYu puts name.size # =\u0026gt; 3 puts name.reverse # =\u0026gt; uYJ puts name.upcase # =\u0026gt; JYU 這跟其他語言其實蠻不一樣的，比如說在 PHP 裡面要知道 String 長度的話，可能會用以下寫法：\necho strlen(\u0026#34;Hello\u0026#34;); 這是因為 Ruby 是完全物件導向的，在 Ruby 中每樣東西都是物件，包括字串和數字。所有的方法都是對物件呼叫，不會看到全域函式1。\nString 還有很多好用的 method 可以用，但這篇文章最主要是要了解 Symbol，所以不列出太多～\nSymbol Symbol 的寫法是在字前面加個冒號，如 :name 或 :title，不是英文也可以，如 :性別。但通常還是以英文為主。\nSymbol 是一個 Symbol 類別的實體，可以用來表示某個狀態，例如：\nclass Order attr_reader :status def initialize(items, status = :pending) @items = items @status = status end def compete @status = :complete end end order = Order.new([\u0026#34;item A\u0026#34;, \u0026#34;item B\u0026#34;, \u0026#34;item C\u0026#34;]) if order.status == :pending puts \u0026#34;order is pending\u0026#34; end 這裡的 :pending 和 :complete 代表的是 pending 和 complete 這兩個「狀態」。Symbol 是一種「帶有名字的物件」，正如其名，Symbol 就是符號，這個符號可用來表示「已完成」或「未完成」。2 在上面這個例子，其實也可以用字串。\n所以 Symbol 和 String 的不同？ 光看上面的例子可能無法知道兩者真正的差異。我們可以用 object_id 這個 method 去印出 Ruby 內部的記憶體配置編號：\nputs \u0026#34;JYU\u0026#34;.object_id # =\u0026gt; 3720 puts \u0026#34;JYU\u0026#34;.object_id # =\u0026gt; 3920 puts :JYU.object_id # =\u0026gt; 3395748 puts :JYU.object_id # =\u0026gt; 3395748 可以發現兩個字串雖然內容相同，也是不同的物件；但 Symbol 只要內容相同，就是相同的物件。這種特性讓 Symbol 的主要用途是作為 Hash 的 Key。3\n所以 Symbol 相對於 String，也更省記憶體一些。\n字串的內容可以變，但 Symbol 不行 Symbol 和字串都有一些好用的 method，例如 length、upcase 或 downcase 等等。不過 Symbol 本身是不能被修改的，但字串可以：\n:JYu.length # =\u0026gt; 3 :JYu.upcase # =\u0026gt; :JYU :JYu[2] # =\u0026gt; \u0026#34;u\u0026#34; \u0026#34;JYu\u0026#34;[2] = \u0026#34;U\u0026#34; # =\u0026gt; \u0026#34;U\u0026#34; :JYu[2] = \u0026#34;U\u0026#34; # =\u0026gt; undefined method `[]=\u0026#39; for :JYu:Symbol (NoMethodError) Symbol 的 Comparison 比字串快 這裡我們直接來看高見龍的測試4：\nrequire \u0026#39;benchmark\u0026#39; loop_times = 100000000 str = Benchmark.measure do loop_times.times do \u0026#34;hello\u0026#34; == \u0026#34;hello\u0026#34; end end.total sym = Benchmark.measure do loop_times.times do :hello == :hello end end.total puts \u0026#34;Benchmark\u0026#34; puts \u0026#34;String: #{str}\u0026#34; puts \u0026#34;Symbol: #{sym}\u0026#34; # =\u0026gt; Benchmark # =\u0026gt; String: 12.299999999999999 # =\u0026gt; Symbol: 5.750000000000002 Symbol 的速度明顯快很多，因為 Symbol 在比較的時候，是直接比對 object_id，而字串還需要逐一比對字母。所以字串在做比較的時間複雜度，會隨著字母數量而增加；而 Symbol 的時間複雜度是固定的。\n使用時機 Symbol 適合當 Hash 裡的 Key 前面有提到 Symbol 的比較速度比較快，所以很適合當 Hash 的 key:\nprofile = { name: \u0026#34;JYu\u0026#34;, age: 23 } # =\u0026gt; {:name=\u0026gt;\u0026#34;JYu\u0026#34;, :age=\u0026gt;23} 字串的 method 比較多 雖然 Symbol 可以當字串用，但是 Symbol 內建的方法沒有像 String 這麼豐富，所以如果想要字串那些好用的功能，就應該選用字串。\nRails 實戰聖經：Ruby 程式語言入門\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n為你自己學 Ruby on Rails：數字、字串、陣列、範圍、雜湊、符號\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRails 實戰聖經：Ruby 程式語言入門\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n為你自己學 Ruby on Rails：數字、字串、陣列、範圍、雜湊、符號\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-05-24T13:34:44+08:00","image":"https://jyu1999.com/post/ruby_string_symbols/1_hu91bb438bb8c442ebbc53e00cb0467e9c_142982_120x120_fill_box_smart1_3.png","permalink":"https://jyu1999.com/post/ruby_string_symbols/","title":"String and Symbol in Ruby"},{"content":"以下是我在 PHPStorm / RubyMine 裡面常用到的快捷鍵。 指令以 Mac 為主，windows 自己換成 Ctrl 即可。\nSearch ⇧⇧ : Search EveryWhere\n可以搜尋全部的檔案。\n⇧ + Cmd + F : Find in path(Full-text Search)\n整個專案的全文檢索。\nView Cmd + ⇧ + F12 : Toggle Maximize Editor\n把全部除了 Editor 的視窗關閉/打開\noption + F12 : Toggle Terminal\n開/關 terminal\nCmd + 1 : Project View\n開/關 Project 檔案列表\nCmd + 2 : Database View (這個不是預設的，是我另外設定的)\n開/關 Database View\nNavigation Cmd + E : Recent File\n最近存取或編輯的檔案\nCmd + B / Cmd + Click : Go to declaration\n去這個 method 宣告的地方\noption + Cmd + ← / → : Navigate back/forward\n返回上一個 Navigation or 去下一個 Navigation（如果有）\nFiles Cmd + ↑ : 選擇檔案 Cmd + N : 新增檔案 實際 Trace Code 可參考以下影片： {{ \u0026lt; youtube nvAlBpbFNNs \u0026gt; }}\n","date":"2023-05-22T10:47:46+08:00","image":"https://jyu1999.com/post/jetbrains_shortcut/0_huc5ecd32684ac79988ff02d7c4a7517e6_153152_120x120_fill_box_smart1_3.png","permalink":"https://jyu1999.com/post/jetbrains_shortcut/","title":"Jetbrains 系列 IDE 的一些快捷鍵（PHPStorm \u0026 RubyMine）"},{"content":"上一篇在 UpdateOperation 中，有一個 update() 的 method，這個 method 又去 call 了一個叫做 update()的 method：\npublic function update() { $this-\u0026gt;crud-\u0026gt;hasAccessOrFail(\u0026#39;update\u0026#39;); // execute the FormRequest authorization and validation, if one is required $request = $this-\u0026gt;crud-\u0026gt;validateRequest(); // register any Model Events defined on fields $this-\u0026gt;crud-\u0026gt;registerFieldEvents(); // update the row in the db $item = $this-\u0026gt;crud-\u0026gt;update( $request-\u0026gt;get($this-\u0026gt;crud-\u0026gt;model-\u0026gt;getKeyName()), $this-\u0026gt;crud-\u0026gt;getStrippedSaveRequest($request) ); $this-\u0026gt;data[\u0026#39;entry\u0026#39;] = $this-\u0026gt;crud-\u0026gt;entry = $item; // show a success message \\Alert::success(trans(\u0026#39;backpack::crud.update_success\u0026#39;))-\u0026gt;flash(); // save the redirect choice for next time $this-\u0026gt;crud-\u0026gt;setSaveAction(); return $this-\u0026gt;crud-\u0026gt;performSaveAction($item-\u0026gt;getKey()); } 這一篇主要就是要探討後面這個 update()。\n這邊來仔細看一下 $this-\u0026gt;crud-\u0026gt;update() 做了些什麼事情。\nupdate() 的具體實現如下：\npublic function update($id, $input) { $item = $this-\u0026gt;model-\u0026gt;findOrFail($id); [$directInputs, $relationInputs] = $this-\u0026gt;splitInputIntoDirectAndRelations($input); $updated = $item-\u0026gt;update($directInputs); $this-\u0026gt;createRelationsForItem($item, $relationInputs); return $item; } findOrFail() 很明顯就是要給定 id，找這個 id 的相關 data。\n而 splitInputIntoDirectAndRelations($input) 是要把 input 分為 DirectInputs 和 RelationDetails 。\n然後下面會把分出來的 $directInputs 存進資料庫裡面，\n最後會用 createRelationsForItem() 幫 $item 和所提供的 model 建立關聯。\n處理關聯的主要是 createRelationsForItem() ，所以這裡繼續來 trace。\ncreateRelationsForItem() 這個 method 需要兩個輸入：\n$item：要創建或更新 relationship 的 model instance $formattedRelations: 包含關聯資訊的 array，是在上面用 getRelationDetailsFromInput() 拿到的。 這個 method 會先檢查 formmattedRelations 是否為空，為空就不用創建 relationships。否則會遍歷 $formattedRelations[]，根據不同的關聯類型來創建或更新相應的 relationships。\n主要有三種 relationship 類型：\nHasOne 或 MorphOne 使用 createUpdateOrDeleteOneToOneRelation() 方法創建或更新一對一關聯。\nprivate function createUpdateOrDeleteOneToOneRelation($relation, $relationMethod, $relationDetails) { $relationMethodValue = $relationDetails[\u0026#39;values\u0026#39;][$relationMethod]; if (is_null($relationMethodValue) \u0026amp;\u0026amp; $relationDetails[\u0026#39;entity\u0026#39;] === $relationMethod) { $relation-\u0026gt;delete(); return null; } if (gettype($relationMethodValue) == \u0026#39;array\u0026#39; \u0026amp;\u0026amp; is_multidimensional_array($relationMethodValue)) { $relationMethodValue = $relationMethodValue[0]; } } // saving process $input = $relationMethodValue ?? $relationDetails[\u0026#39;values\u0026#39;]; [$directInputs, $relationInputs] = $this-\u0026gt;splitInputIntoDirectAndRelations($input, $relationDetails, $relationMethod); $item = $relation-\u0026gt;updateOrCreate([], $directInputs); $this-\u0026gt;createRelationsForItem($item, $relationInputs); return $item; } 根據官方的說法，這個 method 會根據 values 不同，而有不同的處理方式：\n(A) ['number' =\u0026gt; 1315, 'name' =\u0026gt; 'Something'] ：如果使用 text, number, etc\u0026hellip; field (B) ['slug' =\u0026gt; null] ：如果需要清除 slug 和其相關的 entry。 (C) ['passport' =\u0026gt; [['number' =\u0026gt; 1314, 'name' =\u0026gt; 'Something']]] ：如果值是透過 repeatable field 傳遞 (D) ['passport' =\u0026gt; null]：如果值被從 repeatable field 中刪除。 首先，array_key_exists($relationMethod, $relationDetails['values']) 會檢查是不是 (C) or (D)。如果是 (D) 的話，會把 relation 刪掉並回傳 null。\n我還蠻疑惑檢查機制的，於是把 values[] 印出來（雖然這個是多對多）：\n\u0026#34;values\u0026#34; =\u0026gt; array:1 [▼ \u0026#34;articles\u0026#34; =\u0026gt; array:1 [▼ 0 =\u0026gt; \u0026#34;2\u0026#34; ] ] 把檢查機制印出來就一目了然，上面的檢查是在看 model 裡面的 relationship method 是不是 array 的其中一個 key。\n最後，會把這次更新做保存。$directInputs 會 call updateOrCreate() 存進資料庫。然後會把 relation input 傳進 createRelationsForItem() 檢查看還有沒有 relation 需要處理。\nHasMany 或 MorphMany 根據 $relationValues 的結構，使用 attachManyRelation() 建立已存在的 model instance 之間的 relation，或者使用 createManyEntries() 方法創建新的 model instance 並建立 relation。\n$relationValues = $relationDetails[\u0026#39;values\u0026#39;][$relationMethod]; if ($relationValues === null || ! is_multidimensional_array($relationValues)) { $this-\u0026gt;attachManyRelation($item, $relation, $relationDetails, $relationValues); } else { $this-\u0026gt;createManyEntries($item, $relation, $relationMethod, $relationDetails); } break; attachManyRelation() 首先先來看 attachManyRelation()：\nprivate function attachManyRelation($item, $relation, $relationDetails, $relationValues) { $modelInstance = $relation-\u0026gt;getRelated(); $relationForeignKey = $relation-\u0026gt;getForeignKeyName(); $relationLocalKey = $relation-\u0026gt;getLocalKeyName(); if (empty($relationValues)) { return $this-\u0026gt;handleManyRelationItemRemoval($modelInstance, $relation, $relationDetails, $relationForeignKey); } $toUpdate[$relationForeignKey] = $item-\u0026gt;{$relationLocalKey}; if ($relationDetails[\u0026#39;relation_type\u0026#39;] === \u0026#39;MorphMany\u0026#39;) { $toUpdate[$relation-\u0026gt;getQualifiedMorphType()] = $relation-\u0026gt;getMorphClass(); } $modelInstance-\u0026gt;whereIn($modelInstance-\u0026gt;getKeyName(), $relationValues) -\u0026gt;update($toUpdate); $removedEntries = $modelInstance-\u0026gt;whereNotIn($modelInstance-\u0026gt;getKeyName(), $relationValues) -\u0026gt;where($relationForeignKey, $item-\u0026gt;{$relationLocalKey}); if ($relationDetails[\u0026#39;relation_type\u0026#39;] === \u0026#39;MorphMany\u0026#39;) { $removedEntries-\u0026gt;where($relation-\u0026gt;getQualifiedMorphType(), $relation-\u0026gt;getMorphClass()); } return $this-\u0026gt;handleManyRelationItemRemoval($modelInstance, $removedEntries, $relationDetails, $relationForeignKey); } 在 hasmany/morphmany 中，並沒有 「同步(sync)」這個 method 可以用。但當我們在使用 selectable elments 我們需要同步的功能，所以需要寫一些程式去模擬同步，讓使用者可以去新增/刪除那些沒有在 list 裡面的 entries。\n這個 method 會先檢查 relationValues 是否為空，如果為空代表 selection 被清除掉了，所以程式要清除 all related values。會利用 handleManyRelationItemRemoval() 這個 method 來做這件事情，至於這個 method 的實作在下方討論。\n在下面需要把新的 value 加進 relation 裡面，如果是 HasMany 的話，那只需要 update foreign key；如果是 MorphMany 的話，就需要 update foreign key \u0026amp; morphs key。\n下面會從 model instance 找所有不在 $relationValues 的紀錄，也就是在當前 relation 中已經被刪除的紀錄。\n如果 relation type 是 morphmany，還要確保有 match 到 morph type。\n最後，會把已刪除的 entry($removedEntries) 透過 handleManyRelationItemRemoval() 刪除。\nhandleManyRelationItemRemoval() private function handleManyRelationItemRemoval($modelInstance, $removedEntries, $relationDetails, $relationForeignKey) { $relationColumnIsNullable = $modelInstance-\u0026gt;isColumnNullable($relationForeignKey); $forceDelete = $relationDetails[\u0026#39;force_delete\u0026#39;] ?? false; $fallbackId = $relationDetails[\u0026#39;fallback_id\u0026#39;] ?? false; if ($fallbackId) { return $removedEntries-\u0026gt;update([$relationForeignKey =\u0026gt; $fallbackId]); } if ($forceDelete) { return $removedEntries-\u0026gt;lazy()-\u0026gt;each-\u0026gt;delete(); } $dbColumnDefault = $modelInstance-\u0026gt;getDbColumnDefault($relationForeignKey); if (! $relationColumnIsNullable \u0026amp;\u0026amp; $dbColumnDefault === null) { return $removedEntries-\u0026gt;lazy()-\u0026gt;each-\u0026gt;delete(); } return $removedEntries-\u0026gt;update([$relationForeignKey =\u0026gt; $dbColumnDefault]); } 這個 method 主要處理 remove 和特定 relation 相關的 entry。\n一開始會先看有沒有指定 $fallbackId，如果有的話只需要改一下 foreignkey 即可。\n或是如果有設定 force_delete 是 true 的話，就不考慮 foreign key 是否是 nullable，直接刪除所有被移除的 entries。\n如果沒有設定設定 force_delete 的話，則會檢查 foreign key 是否可為空，以及 database 的設定：\nif column 可為空：就設為 default value 就好（沒有的話就設 null） if column 不可為空：會把 entry 從資料庫刪掉，避免資料庫報錯。 createManyEntries() private function createManyEntries($entry, $relation, $relationMethod, $relationDetails) { $items = $relationDetails[\u0026#39;values\u0026#39;][$relationMethod]; $relatedModelLocalKey = $relation-\u0026gt;getRelated()-\u0026gt;getKeyName(); $relatedItemsSent = []; foreach ($items as $item) { [$directInputs, $relationInputs] = $this-\u0026gt;splitInputIntoDirectAndRelations($item, $relationDetails, $relationMethod); $relatedModelLocalKeyValue = $item[$relatedModelLocalKey] ?? null; $item = $entry-\u0026gt;{$relationMethod}()-\u0026gt;updateOrCreate([$relatedModelLocalKey =\u0026gt; $relatedModelLocalKeyValue], $directInputs); $relatedItemsSent[] = $item-\u0026gt;{$relatedModelLocalKey}; $this-\u0026gt;createRelationsForItem($item, $relationInputs); } if (! empty($relatedItemsSent)) { $entry-\u0026gt;{$relationMethod}()-\u0026gt;whereNotIn($relatedModelLocalKey, $relatedItemsSent)-\u0026gt;lazy()-\u0026gt;each-\u0026gt;delete(); } } 首先，會先從 $relationDetails 中獲取和 $relationMethod相關的所有 entries。\n這裡會拿到 model 的 key 之後，宣告一個空陣列 $relatedItemsSent[]，但這邊還看不出來這個是要幹嘛。\n接著，會對所有拿出來的 $items作遍歷，在遍歷的過程中，一樣會先把 direct input 和 relation input 分開，並或去 related model 的 local key value。\n接著，使用model 的 instance，找到匹配的 entry，根據 local key 更新輸入值或創建新的 entry。 已經存進去的會放到 relatedItemSent[]　， 避免重複發送。最後會幫 entry 創建 relation。\n在這個 method 的最後，會去檢查 $relatedItemsSent是否為空。如果是不是空的話，會使用已經發送的 items 和 database 的 local key 作匹配，並刪除沒有在兩者交集裡面的值。\nBelongsToMany 或 MorphToMany 獲取關聯值並確保它們不為空，然後根據值的結構創建或同步多對多關聯。\ncase \u0026#39;BelongsToMany\u0026#39;: case \u0026#39;MorphToMany\u0026#39;: $values = $relationDetails[\u0026#39;values\u0026#39;][$relationMethod] ?? []; $values = is_string($values) ? json_decode($values, true) : $values; $values = $values ?? []; $relationValues = []; if (is_array($values) \u0026amp;\u0026amp; is_multidimensional_array($values)) { foreach ($values as $value) { if (isset($value[$relationMethod])) { $relationValues[$value[$relationMethod]] = Arr::except($value, $relationMethod); } } } if (empty($relationValues)) { $relationValues = array_values($values); } $item-\u0026gt;{$relationMethod}()-\u0026gt;sync($relationValues); break; 首先，會從 $relationDetails 中獲取該 relation 的 value，並確保其為 array。\njson_decode() 可能會回傳 null，因此要確保 $values 不為 null。\n在下面 initialize 一個新的 empty array $relationValues。接著，如果 $values 是 multidimensional_array 的話，就會遍歷 $values，並獲取每個值中的 $relationMethod 作為 key，其餘的值作為 $relationValues 。在這裡是使用 Arr::except($value, $relationMethod) ，代表是要從 $value[] 中移除 $relationMethod 這個 key 及其對應的值。\n如果沒有 relation data，且 values 是一個單維陣列，則為把 $values 的值作為 $relationValues。\n最後，使用$item-\u0026gt;{$relationMethod}()-\u0026gt;sync($relationValues); 同步 relation value。sync() 會把多對多關聯表的現有 relation，更新為這裡所提供的 $relationValues，並在需要時創建新的 relation or 刪除不再存在的 relation。\n","date":"2023-05-19T19:36:26+08:00","image":"https://jyu1999.com/post/backpack05/0_hu10d21063a2d5df6ebb9f3142db7576d3_8853_120x120_fill_box_smart1_3.png","permalink":"https://jyu1999.com/post/backpack05/","title":"Laravel Backpack 初學者之路-05"},{"content":"來研究 UpdateOperation\nHow it works 基本的用法在前幾篇已經看過了，這邊先來看官方的解說。\nCrudController 是一個 RESTful 的 controller，Update Operation 用了兩個 routes:\nGET to /entity-name/{id}/edit: 指到 edit() ，用來 render Edit Form(edit.blade.php) POST to /entity-name/{id}/edit: 指到 update()，使用 Eloquent 去 update database 的 entry edit() 會 render 所有被定義的 fields(using fields API), 接著在保存時，update() 會對資料作 validation，在 Eloquent Model 創建 entry。只有 field type 被加入，且為 $fiilable 的會被真正存入資料庫。\nAdvanced Features and Techniques Validation backpack 提供三種方式，作為表單驗證的機制。\nValidating fields using FormRequests 在產生 CrudController 的時候，會順帶產生一個 Laravel FormRequest，這個 FormRequest 會在 setupUpdateOperation() 裡面被使用。如果是 Article 的話，就是 ArticleRequest::class 。\nCRUD::setValidation(ArticleRequest::class); 對於比較大的 model 來說，這個方式很好用，因為可以在 FormRequest 裡面寫很多 rules, messages and attributes，而且不會影響到 CrudController 的大小。\n如果今天 Create 和 Update 用來 validate 的方式不一樣，就要創建不同的 request file：\nuse App\\Http\\Requests\\CreateTagRequest as StoreRequest; use App\\Http\\Requests\\UpdateTagRequest as UpdateRequest; // ... public function setupCreateOperation() { $this-\u0026gt;crud-\u0026gt;setValidation(CreateRequest::class); } public function setupUpdateOperation() { $this-\u0026gt;crud-\u0026gt;setValidation(UpdateRequest::class); } Validating fields using a rules array 如果是小型的 model，要用另一個檔案來管理也蠻麻煩的，此時可以把 rules 直接寫成 array 就好。\nprotected function setupUpdateOperation() { $this-\u0026gt;crud-\u0026gt;setValidation([ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;required|min:2\u0026#39;, ]); // or maybe $rules = [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;required|min:2\u0026#39;]; $messages = [ \u0026#39;name.required\u0026#39; =\u0026gt; \u0026#39;You gotta give it a name, man.\u0026#39;, \u0026#39;name.min\u0026#39; =\u0026gt; \u0026#39;You came up short. Try more than 2 characters.\u0026#39;, ]; $this-\u0026gt;crud-\u0026gt;setValidation($rules, $messages); } Validating fields using field attributes 另一個對於中小型 model 也不錯用的，是直接寫在 addField() 裡面：\nprotected function setupUpdateOperation() { $this-\u0026gt;crud-\u0026gt;addField([ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;content\u0026#39;, \u0026#39;label\u0026#39; =\u0026gt; \u0026#39;Content\u0026#39;, \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;ckeditor\u0026#39;, \u0026#39;placeholder\u0026#39; =\u0026gt; \u0026#39;Your textarea text here\u0026#39;, \u0026#39;validationRules\u0026#39; =\u0026gt; \u0026#39;required|min:10\u0026#39;, \u0026#39;validationMessages\u0026#39; =\u0026gt; [ \u0026#39;required\u0026#39; =\u0026gt; \u0026#39;You gotta write smth man.\u0026#39;, \u0026#39;min\u0026#39; =\u0026gt; \u0026#39;More than 10 characters, bro. Wtf... You can do this!\u0026#39;, ] ]); // CAREFUL! This MUST be called AFTER the fields are defined, NEVER BEFORE $this-\u0026gt;crud-\u0026gt;setValidation(); } 如果使用這個方法的話，一定要在最後 call setValidation()，不用輸入任何 parameter。 Backpack 會自己去這些 field 裡面找對應的 rules。\nCallbacks 根據 Backpack 文件的說法，在 entry 被更新之前/之後，我們可能想要最一些事情。\n但在 Laravel Backpack 是沒有 callback 可以用的，所以如果要達到這種效果，可以用以下幾種方式。\nUse Events in your setup() method Laravel 已經有提供幾個 events：\nupdating and updated: triggered by the Update operation saving and saved： triggered by both the Create and the Update Operations。 舉例來說，如果想要在 Product entry 更新之前做一些事情，可以：\npublic function setupUpdateOperation() { // ... Product::updating(function($entry) { $entry-\u0026gt;last_edited_by = backpack_user()-\u0026gt;id; }); } 要注意的是，這些events 只有在 function 被 call 的時候才會 register，所以，如果把它定義在 CrudController：\nthey will NOT run when an entry is changed outside that CrudController; if you want to expand the scope to cover both the Create and Update operations, you can easily do that, for example by using the saving and saved events, and moving the event-calling to your main setup() method; Use Events in your field definition 可以在創建 field 的時候，就告訴 field 在 entry 要存進 db 的時候應該要做些什麼：\n// FLUENT syntax - use the convenience method \u0026#34;on\u0026#34; to define just ONE event CRUD::field(\u0026#39;name\u0026#39;)-\u0026gt;on(\u0026#39;updating\u0026#39;, function ($entry) { $entry-\u0026gt;last_edited_by = backpack_user()-\u0026gt;id; }); // FLUENT SYNTAX - you can define multiple events in one go CRUD::field(\u0026#39;name\u0026#39;)-\u0026gt;events([ \u0026#39;updating\u0026#39; =\u0026gt; function ($entry) { $entry-\u0026gt;last_edited_by = backpack_user()-\u0026gt;id; }, \u0026#39;saved\u0026#39; =\u0026gt; function ($entry) { // TODO: upload some file }, ]); // using the ARRAY SYNTAX, define an array of events and closures CRUD::addField([ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;name\u0026#39;, \u0026#39;events\u0026#39; =\u0026gt; [ \u0026#39;updating\u0026#39; =\u0026gt; function ($entry) { $entry-\u0026gt;author_id = backpack_user()-\u0026gt;id; }, ], ]); Override the update() method 把 update() 複寫掉：\n\u0026lt;?php namespace App\\Http\\Controllers\\Admin; use Backpack\\CRUD\\app\\Http\\Controllers\\CrudController; class ProductCrudController extends CrudController { use \\Backpack\\CRUD\\app\\Http\\Controllers\\Operations\\UpdateOperation { update as traitUpdate; } // ... public function update() { // do something before validation, before save, before everything; for example: // $this-\u0026gt;crud-\u0026gt;addField([\u0026#39;type\u0026#39; =\u0026gt; \u0026#39;hidden\u0026#39;, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;author_id\u0026#39;]); // $this-\u0026gt;crud-\u0026gt;removeField(\u0026#39;password_confirmation\u0026#39;); // Note: By default Backpack ONLY saves the inputs that were added on page using Backpack fields. // This is done by stripping the request of all inputs that do NOT match Backpack fields for this // particular operation. This is an added security layer, to protect your database from malicious // users who could theoretically add inputs using DeveloperTools or JavaScript. If you\u0026#39;re not properly // using $guarded or $fillable on your model, malicious inputs could get you into trouble. // However, if you know you have proper $guarded or $fillable on your model, and you want to manipulate // the request directly to add or remove request parameters, you can also do that. // We have a config value you can set, either inside your operation in `config/backpack/crud.php` if // you want it to apply to all CRUDs, or inside a particular CrudController: // $this-\u0026gt;crud-\u0026gt;setOperationSetting(\u0026#39;saveAllInputsExcept\u0026#39;, [\u0026#39;_token\u0026#39;, \u0026#39;_method\u0026#39;, \u0026#39;http_referrer\u0026#39;, \u0026#39;current_tab\u0026#39;, \u0026#39;save_action\u0026#39;]); // The above will make Backpack store all inputs EXCEPT for the ones it uses for various features. // So you can manipulate the request and add any request variable you\u0026#39;d like. // $this-\u0026gt;crud-\u0026gt;getRequest()-\u0026gt;request-\u0026gt;add([\u0026#39;author_id\u0026#39;=\u0026gt; backpack_user()-\u0026gt;id]); // $this-\u0026gt;crud-\u0026gt;getRequest()-\u0026gt;request-\u0026gt;remove(\u0026#39;password_confirmation\u0026#39;); // $this-\u0026gt;crud-\u0026gt;getRequest()-\u0026gt;request-\u0026gt;add([\u0026#39;author_id\u0026#39;=\u0026gt; backpack_user()-\u0026gt;id]); // $this-\u0026gt;crud-\u0026gt;getRequest()-\u0026gt;request-\u0026gt;remove(\u0026#39;password_confirmation\u0026#39;); $response = $this-\u0026gt;traitUpdate(); // do something after save return $response; } } Delete button on Update Operation 如果想要在 Update operation 裡面顯示 Delete button，需要在 setupUpdateOperation()裡面加上：\nprotected function setupUpdateOperation() { // your code... $this-\u0026gt;crud-\u0026gt;setOperationSetting(\u0026#39;showDeleteButton\u0026#39;, true); // \u0026lt;--- add this! // alternatively you can pass an URL to where user should be redirected after entry is deleted: // $this-\u0026gt;crud-\u0026gt;setOperationSetting(\u0026#39;showDeleteButton\u0026#39;, \u0026#39;https://someurl.com\u0026#39;); } 這可以讓我們可以直接在 update 的畫面刪掉 entries。\nTrace Code - UpdateOperation 接著來看 UpdateOperation 這個 trait 裡面的一些 method：\nsetupUpdateRoutes protected function setupUpdateRoutes($segment, $routeName, $controller) { Route::get($segment.\u0026#39;/{id}/edit\u0026#39;, [ \u0026#39;as\u0026#39; =\u0026gt; $routeName.\u0026#39;.edit\u0026#39;, \u0026#39;uses\u0026#39; =\u0026gt; $controller.\u0026#39;@edit\u0026#39;, \u0026#39;operation\u0026#39; =\u0026gt; \u0026#39;update\u0026#39;, ]); Route::put($segment.\u0026#39;/{id}\u0026#39;, [ \u0026#39;as\u0026#39; =\u0026gt; $routeName.\u0026#39;.update\u0026#39;, \u0026#39;uses\u0026#39; =\u0026gt; $controller.\u0026#39;@update\u0026#39;, \u0026#39;operation\u0026#39; =\u0026gt; \u0026#39;update\u0026#39;, ]); } 還蠻明顯這個 method 就是在創建兩個 route，一個是 GET:admin/article/{id}/edit，會導到編輯的那一頁。另一個是 PUT: admin/article/{id} ，就是編輯完按下 save 會導到的 route。\n不過我還蠻好奇這個 method 是在哪裡被 call 的，因為只要一創建 crudController，就會馬上有 route 可以用。\n後來發現一開始是在 EntityCrudController 所繼承的 CrudController 裡面的__construct()：\npublic function __construct() { if ($this-\u0026gt;crud) { return; } // --------------------------- // Create the CrudPanel object // --------------------------- // Used by developers inside their ProductCrudControllers as // $this-\u0026gt;crud or using the CRUD facade. // // It\u0026#39;s done inside a middleware closure in order to have // the complete request inside the CrudPanel object. $this-\u0026gt;middleware(function ($request, $next) { $this-\u0026gt;crud = app(\u0026#39;crud\u0026#39;); $this-\u0026gt;crud-\u0026gt;setRequest($request); $this-\u0026gt;setupDefaults(); $this-\u0026gt;setup(); $this-\u0026gt;setupConfigurationForCurrentOperation(); return $next($request); }); } 這個裡面會 call setup()，但目前這個 parent class 的 setup()沒有實作，所以要去看各 crudController 的 setup()，這裡用 article 為例：\npublic function setup() { CRUD::setModel(\\App\\Models\\Article::class); CRUD::setRoute(config(\u0026#39;backpack.base.route_prefix\u0026#39;) . \u0026#39;/article\u0026#39;); CRUD::setEntityNameStrings(\u0026#39;article\u0026#39;, \u0026#39;articles\u0026#39;); } 這裡會 call setRoute()，而 setRoute() 是在 parent class(CrudController) 所 implement 的：\npublic function setupRoutes($segment, $routeName, $controller) { preg_match_all(\u0026#39;/(?\u0026lt;=^|;)setup([^;]+?)Routes(;|$)/\u0026#39;, implode(\u0026#39;;\u0026#39;, get_class_methods($this)), $matches); if (count($matches[1])) { foreach ($matches[1] as $methodName) { $this-\u0026gt;{\u0026#39;setup\u0026#39;.$methodName.\u0026#39;Routes\u0026#39;}($segment, $routeName, $controller); } } } 可以看到這裡就會 call 'setup'.$methodName.'Routes' 並傳入需要的 parameters。\nsetupUpdateDefaults protected function setupUpdateDefaults() { $this-\u0026gt;crud-\u0026gt;allowAccess(\u0026#39;update\u0026#39;); $this-\u0026gt;crud-\u0026gt;operation(\u0026#39;update\u0026#39;, function () { $this-\u0026gt;crud-\u0026gt;loadDefaultOperationSettingsFromConfig(); if ($this-\u0026gt;crud-\u0026gt;getModel()-\u0026gt;translationEnabled()) { $this-\u0026gt;crud-\u0026gt;addField([ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;_locale\u0026#39;, \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;hidden\u0026#39;, \u0026#39;value\u0026#39; =\u0026gt; request()-\u0026gt;input(\u0026#39;_locale\u0026#39;) ?? app()-\u0026gt;getLocale(), ]); } $this-\u0026gt;crud-\u0026gt;setupDefaultSaveActions(); }); $this-\u0026gt;crud-\u0026gt;operation([\u0026#39;list\u0026#39;, \u0026#39;show\u0026#39;], function () { $this-\u0026gt;crud-\u0026gt;addButton(\u0026#39;line\u0026#39;, \u0026#39;update\u0026#39;, \u0026#39;view\u0026#39;, \u0026#39;crud::buttons.update\u0026#39;, \u0026#39;end\u0026#39;); }); } 從名字來看大致可以知道，setupUpdateDefaults 負責設定更新操作所需的預設設定。\nallowAccess() 允許 CRUDController 有權限可以使用 update。會把操作名稱（update）添加到允許訪問的列表中。在這邊是把 update 設置為允許訪問。\noperation()是在定義名為 update 的操作，並用一個 closure 來設定 update 要作什麼事情。\nloadDefaultOperationSettingsFromConfig() 就是在 load 配置文件，通常位於 config/backpack/operations，\n下面會看 model 有沒有啟用翻譯，如果有的話，會新增一個 hidden 的欄位。這個是用來儲存目前的語言設置（當前選擇的語言），以便在多語言網頁上正確更新相應的翻譯。\nsetupDefaultSaveActions()主要用於設置 default 的保存操作。包含 save_and_back 、save_and_edit、save_and_new。\n這個 setupDefaultSaveActions() 會在 Save and back 按鈕旁邊的小箭頭出現，如下圖：\n最後，在 operation 是 list, show 的情況下，執行 addbutton，也就是 Add a button to the CRUD table view.。\nedit Show the form for editing the specified resource.\npublic function edit($id) { $this-\u0026gt;crud-\u0026gt;hasAccessOrFail(\u0026#39;update\u0026#39;); // get entry ID from Request (makes sure its the last ID for nested resources) $id = $this-\u0026gt;crud-\u0026gt;getCurrentEntryId() ?? $id; // get the info for that entry $this-\u0026gt;data[\u0026#39;entry\u0026#39;] = $this-\u0026gt;crud-\u0026gt;getEntryWithLocale($id); $this-\u0026gt;crud-\u0026gt;setOperationSetting(\u0026#39;fields\u0026#39;, $this-\u0026gt;crud-\u0026gt;getUpdateFields()); $this-\u0026gt;data[\u0026#39;crud\u0026#39;] = $this-\u0026gt;crud; $this-\u0026gt;data[\u0026#39;saveAction\u0026#39;] = $this-\u0026gt;crud-\u0026gt;getSaveAction(); $this-\u0026gt;data[\u0026#39;title\u0026#39;] = $this-\u0026gt;crud-\u0026gt;getTitle() ?? trans(\u0026#39;backpack::crud.edit\u0026#39;).\u0026#39; \u0026#39;.$this-\u0026gt;crud-\u0026gt;entity_name; $this-\u0026gt;data[\u0026#39;id\u0026#39;] = $id; // load the view from /resources/views/vendor/backpack/crud/ if it exists, otherwise load the one in the package return view($this-\u0026gt;crud-\u0026gt;getEditView(), $this-\u0026gt;data); } edit() 會寫在對應的 route 裡面：\nRoute::get($segment.\u0026#39;/{id}/edit\u0026#39;, [ \u0026#39;as\u0026#39; =\u0026gt; $routeName.\u0026#39;.edit\u0026#39;, \u0026#39;uses\u0026#39; =\u0026gt; $controller.\u0026#39;@edit\u0026#39;, \u0026#39;operation\u0026#39; =\u0026gt; \u0026#39;update\u0026#39;, ]); 這邊其實就寫了當 user 輸入這個 url，會 call edit 這個 method。\n首先進入 edit，會檢查是否可以 access update（在 setupUpdateDefaults() 裡面會新增）。如果沒有就不能編輯。\n接著會取得 id，知道要編輯哪個 entry。\n接著，使用 getEntryWithLocale() 得到特定語言區域的資源。這個 method 會先看是否已經有 entry，還沒有的話會 call getEntry() 來拿到 entry。接著，會去看這個 entry 是否支援翻譯，然後從request 去找可用語言區域列表。如果有的話，會用 setLocale($locale)將語言區域設置為 request 指定的語言區域。\n下面的 setOperationSetting() 會把 operation 存成 key-value store，這樣之後可以方便查找。\n然後再下面的程式碼，主要就是把一些資訊存進 data，並在最後一起傳到 view 裡面。\n而 getEditView() 的實現如下：\npublic function getEditView() { return $this-\u0026gt;get(\u0026#39;update.view\u0026#39;) ?? \u0026#39;crud::edit\u0026#39;; } 看起來就是先檢查使用者有沒有自定義 update view，如果沒有的話，就用 backpack 預設的。\n官方文件 上有寫一些方法，關於創建如何客製化自己的 view。\n$this-\u0026gt;crud-\u0026gt;setShowView(\u0026#39;your-view\u0026#39;); $this-\u0026gt;crud-\u0026gt;setEditView(\u0026#39;your-view\u0026#39;); $this-\u0026gt;crud-\u0026gt;setCreateView(\u0026#39;your-view\u0026#39;); $this-\u0026gt;crud-\u0026gt;setListView(\u0026#39;your-view\u0026#39;); $this-\u0026gt;crud-\u0026gt;setReorderView(\u0026#39;your-view\u0026#39;); $this-\u0026gt;crud-\u0026gt;setDetailsRowView(\u0026#39;your-view\u0026#39;); update Update the specified resource in the database.\npublic function update() { $this-\u0026gt;crud-\u0026gt;hasAccessOrFail(\u0026#39;update\u0026#39;); // execute the FormRequest authorization and validation, if one is required $request = $this-\u0026gt;crud-\u0026gt;validateRequest(); // register any Model Events defined on fields $this-\u0026gt;crud-\u0026gt;registerFieldEvents(); // update the row in the db $item = $this-\u0026gt;crud-\u0026gt;update( $request-\u0026gt;get($this-\u0026gt;crud-\u0026gt;model-\u0026gt;getKeyName()), $this-\u0026gt;crud-\u0026gt;getStrippedSaveRequest($request) ); $this-\u0026gt;data[\u0026#39;entry\u0026#39;] = $this-\u0026gt;crud-\u0026gt;entry = $item; // show a success message \\Alert::success(trans(\u0026#39;backpack::crud.update_success\u0026#39;))-\u0026gt;flash(); // save the redirect choice for next time $this-\u0026gt;crud-\u0026gt;setSaveAction(); return $this-\u0026gt;crud-\u0026gt;performSaveAction($item-\u0026gt;getKey()); } 跟上面的 edit() 一樣，update 會先檢查有沒有 access。\n如果有的話，那就 call validateRequest() 來驗證輸入，這邊的驗證會同時看 FormRequst 和寫在裡面的 rules。\n驗證通過後，會 call regusterFieldEvents() ，看起來是會把在 field 裡面有定義的所有 Eloquent Model Events 註冊。在上面的 [[#^eb7633|Callback]] 有提到怎麼定義 Eloquent Model Events。\n接著會 call update() 把資料存進 db 裡面，getStrippedSaveRequest() 是會把 request 做一些處理。\n存進 db 後，會再把更新後的 entry 存到 data[]，方便後續的操作。\n最後就是顯示 flash message 並 redirect ㄌ。\n結語 程式碼蠻多的，但愈看愈有感覺，因為前面原本沒有很了解的東西，都會慢慢能了解實作。但也不知道要挖到多深就是ㄌ。 好像可以去研究一下 Laravel Form Request Validation 和 Eloquent Events。 ","date":"2023-05-19T19:35:41+08:00","image":"https://jyu1999.com/post/backpack04/0_hu10d21063a2d5df6ebb9f3142db7576d3_8853_120x120_fill_box_smart1_3.png","permalink":"https://jyu1999.com/post/backpack04/","title":"Laravel Backpack 初學者之路-04"},{"content":"這篇主要是要來研究 Fields。\nIntro. 在前兩篇可以看到，fields types 定義了 admin 可以如何輸入資料，例如 text, datepicker, upload button\u0026hellip;等等。通常是給 Create or Update 使用。\n在 Backpack 裡面，有很多的預設的 field types，也可以創建自己的 field。如果只是要做一點點修改，也可以 overwrite 原本的 field type 就好。\nFields API 在官網上列出了用於操作 fields 的一些方法。\n這些 method 會在 operation 裡面運作，所以一定要放在 setupCreateOperation() 、 setUpdatePeration() or setup() 裡面。\n（好像在 version 5 之後，也可以使用靜態的方式去 call，如 CRUD::addfield()。\n// add a field $this-\u0026gt;crud-\u0026gt;addField($field_definition_array); // shorthand: add a text field $this-\u0026gt;crud-\u0026gt;addField(\u0026#39;db_column_name\u0026#39;); // add multiple fields $this-\u0026gt;crud-\u0026gt;addFields([$field_definition_array_1, $field_definition_array_2]); // change the attributes of a field $this-\u0026gt;crud-\u0026gt;modifyField($name, $modifs_array); // remove a field from both operations $this-\u0026gt;crud-\u0026gt;removeField(\u0026#39;name\u0026#39;); // remove multiple fields from both operations $this-\u0026gt;crud-\u0026gt;removeFields($array_of_names); // remove all fields from all operations $this-\u0026gt;crud-\u0026gt;removeAllFields(); // FIELD ORDER // add a field before a given field $this-\u0026gt;crud-\u0026gt;addField($field_definition_array)-\u0026gt;beforeField(\u0026#39;name\u0026#39;); // add a field after a given field $this-\u0026gt;crud-\u0026gt;addField($field_definition_array)-\u0026gt;afterField(\u0026#39;name\u0026#39;); // ------------------- // New in Backpack 4.1 // ------------------- // add a field with this name $this-\u0026gt;crud-\u0026gt;field(\u0026#39;price\u0026#39;); // change the type attribute on the \u0026#39;price\u0026#39; field $this-\u0026gt;crud-\u0026gt;field(\u0026#39;price\u0026#39;)-\u0026gt;type(\u0026#39;number\u0026#39;); Field Attributes Mandatory Field Attributes 只有一個 attributes 是強迫要有的： name。\n這個 name 會被怎麼使用？官網上提供了兩個：\ninside the inputs, as \u0026lt;input name='your_db_column' /\u0026gt;; to store the information in the database, so your name should correspond to a database column (if the field type doesn\u0026rsquo;t have different instructions); Recommended Field Attributes 一個 field 也最好有以下的 field:\nthe name of the column in the database (ex: \u0026ldquo;title\u0026rdquo;) the human-readable label for the input (ex: \u0026ldquo;Title\u0026rdquo;) the type of the input (ex: \u0026ldquo;text\u0026rdquo;) 如果 label 被省略的話， backpack 會嘗試從 name 猜一下 label。 如果 type 被省略的話， backpack 會根據 column type 來猜，或是 Model 有一個名為 name 的 relationship。\nField Attributes for Presentation Purposes 有一些選擇性可用的 attributes 可以用在大部分的 default field types 上，可以讓人很簡單的達到一些效果：\n[ \u0026#39;prefix\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;suffix\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;default\u0026#39; =\u0026gt; \u0026#39;some value\u0026#39;, // set a default value \u0026#39;hint\u0026#39; =\u0026gt; \u0026#39;Some hint text\u0026#39;, // helpful text, shows up after the input \u0026#39;attributes\u0026#39; =\u0026gt; [ \u0026#39;placeholder\u0026#39; =\u0026gt; \u0026#39;Some text when empty\u0026#39;, \u0026#39;class\u0026#39; =\u0026gt; \u0026#39;form-control some-class\u0026#39;, \u0026#39;readonly\u0026#39; =\u0026gt; \u0026#39;readonly\u0026#39;, \u0026#39;disabled\u0026#39; =\u0026gt; \u0026#39;disabled\u0026#39;, ], // change the HTML attributes of your input \u0026#39;wrapper\u0026#39; =\u0026gt; [ \u0026#39;class\u0026#39; =\u0026gt; \u0026#39;form-group col-md-12\u0026#39; ], // change the HTML attributes for the field wrapper - mostly for resizing fields ] 看起來蠻有用的，之前有用過 'prefix'，可以加入前贅詞。\nFake Field Attributes (stores fake attributes as JSON in the database) 如果今天要存的資料有多種，但資料庫裡只有一欄，此時就需要先把資料轉成 JSON 格式再存進資料庫。\n預設來說，會存在 extras 這個 column。\n要使用 fake field attributes，有以下步驟：\n在 field 裡面加入 fake attribute [ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;name\u0026#39;, // JSON variable name \u0026#39;label\u0026#39; =\u0026gt; \u0026#34;Tag Name\u0026#34;, // human-readable label for the input \u0026#39;fake\u0026#39; =\u0026gt; true, // show the field, but don\u0026#39;t store it in the database column above \u0026#39;store_in\u0026#39; =\u0026gt; \u0026#39;extras\u0026#39; // [optional] the database column name where you want the fake fields to ACTUALLY be stored as a JSON array ], 在 model 裡面，要確認存 JSONs 的 db columns(default: extras) 有： In the $fillable property; on a new $fakeColumns property(create it now) are cast as array in $casts Tab Attribute Splits Forms into Tabs 可以把 create/edit input 放在不同的 tabs 裡面。 如果要使用這個功能，要在 field attribute 裡面加上 \u0026rsquo;tab\u0026rsquo;。 舉例而言，如果我想要把 price 放在 test 這個 tab 裡面，然後把 articles 這個 select2_multiple 放在 hello 這個 tab 裡面，可以這樣寫：\nCRUD::addField([ \u0026#39;name\u0026#39;=\u0026gt;\u0026#39;price\u0026#39;, \u0026#39;type\u0026#39;=\u0026gt;\u0026#39;number\u0026#39;, \u0026#39;tab\u0026#39;=\u0026gt;\u0026#39;test\u0026#39; ]); CRUD::addField([ \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;select2_multiple\u0026#39;, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;articles\u0026#39;, // the relationship name in your Model \u0026#39;entity\u0026#39; =\u0026gt; \u0026#39;articles\u0026#39;, // the relationship name in your Model \u0026#39;attribute\u0026#39; =\u0026gt; \u0026#39;topic\u0026#39;, // attribute on Article that is shown to admin \u0026#39;pivot\u0026#39; =\u0026gt; true, // on create\u0026amp;update, do you need to add/delete pivot table entries? \u0026#39;tab\u0026#39;=\u0026gt;\u0026#39;hello\u0026#39; ]); 最後呈現出來的效果：\n可以看到如果沒有指定 tab 的，會獨立是一個 component，放在所有 tabs 的上面。\nAttributes For Fields Containing Related Entries 這邊主要是在說，如果 field works with related entities( relationships like BelongsTo , HasOne, HasMany, BelongsToMany, etc)，有一些參數需要/可以設定。\nentity - points to the method on the model that contains the relationship; having this defined, Backpack will try to guess from it all other field attributes; ex: category or tags; model - the classname (including namespace) of the related model (ex: App\\Models\\Category); usually deduced from the relationship function in the model; attribute - the attribute on the related model (aka foreign attribute) that will be show to the user; for example, you wouldn\u0026rsquo;t want a dropdown of categories showing IDs - no, you\u0026rsquo;d want to show the category names; in this case, the attribute will be name; usually deduced using the identifiable attribute functionality explained below; multiple - boolean, allows the user to pick one or multiple items; usually deduced depending on whether it\u0026rsquo;s a 1-to-n or n-n relationship; pivot - boolean, instructs Backpack to store the information inside a pivot table; usually deduced depending on whether it\u0026rsquo;s a 1-to-n or n-n relationship; relation_type - text, deduced from entity; not a good idea to overwrite; 其實看前幾天做的 select2_multiple 大概就可以知道怎麼用了。\n很多個 field 文件後面就是各個不同的 field 介紹，這個就挑著記。\nRelationship 會給 user 一個 select2 input，讓使用者可以選擇一個或多個關聯的 Eloquent Model 的 entires。 為了要正常運作，在 Model 裡面必須要正確定義 relationships。 在官網上有列出有支持的 relationships。\nLoad entries from AJAX calls - using the Fetch Operation 如果同時要 load 很多 entries，用 onpage Eloquent query 速度可能會很慢。 在這種情況下，可以叫 relationship field 透過 AJAX calls 來拿到 entries。 要達成這樣的效果，有以下步驟：\nAdd 'ajax' =\u0026gt; true to your relationship field definition: [ // relationship \u0026#39;type\u0026#39; =\u0026gt; \u0026#34;relationship\u0026#34;, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;category\u0026#39;, // the method on your model that defines the relationship \u0026#39;ajax\u0026#39; =\u0026gt; true, // OPTIONALS: // \u0026#39;label\u0026#39; =\u0026gt; \u0026#34;Category\u0026#34;, // \u0026#39;attribute\u0026#39; =\u0026gt; \u0026#34;name\u0026#34;, // foreign key attribute that is shown to user (identifiable attribute) // \u0026#39;entity\u0026#39; =\u0026gt; \u0026#39;category\u0026#39;, // the method that defines the relationship in your Model // \u0026#39;model\u0026#39; =\u0026gt; \u0026#34;App\\Models\\Category\u0026#34;, // foreign key Eloquent model // \u0026#39;placeholder\u0026#39; =\u0026gt; \u0026#34;Select a category\u0026#34;, // placeholder for the select2 input // AJAX OPTIONALS: // \u0026#39;delay\u0026#39; =\u0026gt; 500, // the minimum amount of time between ajax requests when searching in the field // \u0026#39;data_source\u0026#39; =\u0026gt; url(\u0026#34;fetch/category\u0026#34;), // url to controller search function (with /{id} should return model) // \u0026#39;minimum_input_length\u0026#39; =\u0026gt; 2, // minimum characters to type before querying results // \u0026#39;dependencies\u0026#39; =\u0026gt; [\u0026#39;category\u0026#39;], // when a dependency changes, this select2 is reset to null // \u0026#39;method\u0026#39; =\u0026gt; \u0026#39;POST\u0026#39;, // optional - HTTP method to use for the AJAX call (GET, POST) // \u0026#39;include_all_form_fields\u0026#39; =\u0026gt; false, // optional - only send the current field through AJAX (for a smaller payload if you\u0026#39;re not using multiple chained select2s) ], 主要應該是 'ajax'=\u0026gt;true 這行。 所以我嘗試在 ArticleCrudController.php 裡面把原本的 select2 改掉： CRUD::addField([ \u0026#39;label\u0026#39; =\u0026gt; \u0026#34;Tags\u0026#34;, \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;relationship\u0026#39;, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;tags\u0026#39;, // the method that defines the relationship in your Model \u0026#39;entity\u0026#39; =\u0026gt; \u0026#39;tags\u0026#39;, // the method that defines the relationship in your Model \u0026#39;attribute\u0026#39; =\u0026gt; \u0026#39;name\u0026#39;, // foreign key attribute that is shown to user \u0026#39;pivot\u0026#39; =\u0026gt; true, // on create\u0026amp;update, do you need to add/delete pivot table entries? \u0026#39;ajax\u0026#39;=\u0026gt;true ]); 此時應該是會報錯，看起來是根本沒有 router： 這時候就要到第二步驟，在ArticleCrudController.php加入以下程式碼： use \\Backpack\\CRUD\\app\\Http\\Controllers\\Operations\\FetchOperation; public function fetchTags() { return $this-\u0026gt;fetch(\\App\\Models\\Tag::class); } 這段程式碼的用途就是要開一個對應到 AJAX Calls 的 route 和 method。 會幫我們設定好 /fetch/tag route，會導到 fetchTags()，並 return 搜尋結果。 感覺蠻有趣的，[官方文件](FetchOperation docs)有說明更多關於怎麼 operation 怎麼運作的，不過先暫時跳過\u0026hellip; Create related entries in a modal - using the InlineCreate Operation 使用者去使用 AJAX 做搜尋，有可能根本沒有這個資料。\n所以可能會需要讓使用者在不用離開原本的頁面下，新增一個 related entry。(e.g. 在 create article 的頁面新增一個 tag)\n這個功能可以使用在 BelongsTo, BelongsToMany, MorphToMany relationships。\n要使用這個功能，要先使用 Fetch operation 去拿到 entries。\n然後再照以下步驟：\n增加 inline_create 在 field definition // for 1-n relationships (ex: category) [ \u0026#39;type\u0026#39; =\u0026gt; \u0026#34;relationship\u0026#34;, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;category\u0026#39;, \u0026#39;ajax\u0026#39; =\u0026gt; true, \u0026#39;inline_create\u0026#39; =\u0026gt; true, // \u0026lt;--- THIS ], // for n-n relationships (ex: tags) [ \u0026#39;type\u0026#39; =\u0026gt; \u0026#34;relationship\u0026#34;, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;tags\u0026#39;, // the method on your model that defines the relationship \u0026#39;ajax\u0026#39; =\u0026gt; true, \u0026#39;inline_create\u0026#39; =\u0026gt; [ \u0026#39;entity\u0026#39; =\u0026gt; \u0026#39;tag\u0026#39; ] // \u0026lt;--- OR THIS ], // in this second example, the relation is called `tags` (plural), // but we need to define the entity as \u0026#34;tag\u0026#34; (singural) 這時候應該會看到以下 bug，跟上面的 fetch 一樣，目前還沒有 route 可以處理這個請求。所以要進入第二步驟。 2. 要在 secondary entity （在這個例子中是 TagCrudController）中 use InlineCreate operation\nclass TagCrudController extends CrudController { use \\Backpack\\CRUD\\app\\Http\\Controllers\\Operations\\InlineCreateOperation; // ... } 加入之後看 artisan route:list 就會看到 backpack 幫我們生成一個 route 了：\nGET|HEAD admin/tag/create ....................... tag.create › Admin\\TagCrudController@create POST admin/tag/inline/create tag-inline-create-save › Admin\\TagCrudController@storeInlin… POST admin/tag/inline/create/modal tag-inline-create › Admin\\TagCrudController@getInline… ``` `InlineCreateOperation` 會讓 modal 顯示和 Create Operation 一樣的 field。 #### Save additional data to pivot table 對於有 pivot table 的 relationship(n2n: `BelongsToMany`, `MorphToMany`)，這個 pivot table 除了 foreign key 之外，還可能包含其他列。 `relationship` field 提供了一個快速的方法，讓 admin 可以編輯這些 \u0026#34;extra attributes\u0026#34; 。 舉例而言，如果有以下 db tables: ```php // - companies: id, name // - company_person: company_id, person_id, job_title, job_description // - persons: id, first_name, last_name 在 company_person 這個 pivot table 裡面，我們可能想要讓 admin 去編輯特定使用者的 job_title 或是 job_description 。如下圖： 步驟如下（在這裡就不實作ㄌ）：\n在 model 裡面，確認 pivot 有被 define（使用 withPivot()）: // inside the Company model public function people() { return $this-\u0026gt;belongsToMany(\\App\\Models\\Person::class) -\u0026gt;withPivot(\u0026#39;job_title\u0026#39;, \u0026#39;job_description\u0026#39;); } // inside the Person model public function companies() { return $this-\u0026gt;belongsToMany(\\App\\Models\\Company::class) -\u0026gt;withPivot(\u0026#39;job_title\u0026#39;, \u0026#39;job_description\u0026#39;); } 在 relationship field defintion, 加入 subfield // Inside PersonCrudController [ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;companies\u0026#39;, \u0026#39;type\u0026#39; =\u0026gt; \u0026#34;relationship\u0026#34;, // .. \u0026#39;subfields\u0026#39; =\u0026gt; [ [ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;job_title\u0026#39;, \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;text\u0026#39;, \u0026#39;wrapper\u0026#39; =\u0026gt; [ \u0026#39;class\u0026#39; =\u0026gt; \u0026#39;form-group col-md-3\u0026#39;, ], ], [ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;job_description\u0026#39;, \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;text\u0026#39;, \u0026#39;wrapper\u0026#39; =\u0026gt; [ \u0026#39;class\u0026#39; =\u0026gt; \u0026#39;form-group col-md-9\u0026#39;, ], ], ], ], Manage related entries in the same form (create, update, delete) 有時候對於 hasMany 和 morphMany relationships，secondary entry 高度依賴 primary entry，所以我們可能不想要在一個額外的懸浮式視窗來編輯這個 secondary entry。\nDelete related entries or fall back to default 一般而言，當 admin 在 \u0026ldquo;select\u0026rdquo; 裡面移除了一個 relationship，只有 relationship 被移除，related entry 會保留。\n但對於 hasMany 和 morphMany 來說，有時候我們可能也會想要移除一整個 relationship。\n如下例：\n// Inside ArticleCrudController [ \u0026#39;type\u0026#39; =\u0026gt; \u0026#34;relationship\u0026#34;, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;comments\u0026#39;, // when removed, use fallback_id \u0026#39;fallback_id\u0026#39; =\u0026gt; 3, // will relate to the comment with ID \u0026#34;3\u0026#34; // when removed, delete the entry \u0026#39;force_delete\u0026#39; =\u0026gt; true, // will delete that comment ], Repeatable 有時候我們可能想要給 admin 可以同時新增很多欄位。\n比如說，在「台灣國家公園入園入山申請」之中，可以按下「新增隊員」，就可以新增很多欄位 （for 這個隊員）。\n這個時候就可以用到 repeatable。\n從 backpack v5 版本開始，repeatable 會 return array，會需要在 model 裡面設定 cast 成 json，再存成資料庫。\n可以按下 \u0026ldquo;New item\u0026rdquo; 按鈕，就會增加新的 subfields group（e.g. 一個新隊員）。\n大部分的 field type 都可以用在 field group 裡面，也可以使用 wrapper 更改每個 field 的寬度。\n但有以下事情是需要注意的：\n所有在 group 裡面的 subfields 都需要定義清楚，Backpack 不會幫忙猜 Label 之類的。 有些 field type 是不可以在 subfield 使用的，例如 relationship field、upload、upload_multiple Validation: 可以透過 Laravel nested array validation 的方式來驗證 subfield 的資料。e.g. testimonial.*.name =\u0026gt; 'required' Filed usage and relationships: 不能在 repeatable field 裡面再塞一個 repeatable field。 [ // repeatable \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;testimonials\u0026#39;, \u0026#39;label\u0026#39; =\u0026gt; \u0026#39;Testimonials\u0026#39;, \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;repeatable\u0026#39;, \u0026#39;subfields\u0026#39; =\u0026gt; [ // also works as: \u0026#34;fields\u0026#34; [ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;name\u0026#39;, \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;text\u0026#39;, \u0026#39;label\u0026#39; =\u0026gt; \u0026#39;Name\u0026#39;, \u0026#39;wrapper\u0026#39; =\u0026gt; [\u0026#39;class\u0026#39; =\u0026gt; \u0026#39;form-group col-md-4\u0026#39;], ], [ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;position\u0026#39;, \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;text\u0026#39;, \u0026#39;label\u0026#39; =\u0026gt; \u0026#39;Position\u0026#39;, \u0026#39;wrapper\u0026#39; =\u0026gt; [\u0026#39;class\u0026#39; =\u0026gt; \u0026#39;form-group col-md-4\u0026#39;], ], [ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;company\u0026#39;, \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;text\u0026#39;, \u0026#39;label\u0026#39; =\u0026gt; \u0026#39;Company\u0026#39;, \u0026#39;wrapper\u0026#39; =\u0026gt; [\u0026#39;class\u0026#39; =\u0026gt; \u0026#39;form-group col-md-4\u0026#39;], ], [ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;quote\u0026#39;, \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;ckeditor\u0026#39;, \u0026#39;label\u0026#39; =\u0026gt; \u0026#39;Quote\u0026#39;, ], ], // optional \u0026#39;new_item_label\u0026#39; =\u0026gt; \u0026#39;Add Group\u0026#39;, // customize the text of the button \u0026#39;init_rows\u0026#39; =\u0026gt; 2, // number of empty rows to be initialized, by default 1 \u0026#39;min_rows\u0026#39; =\u0026gt; 2, // minimum rows allowed, when reached the \u0026#34;delete\u0026#34; buttons will be hidden \u0026#39;max_rows\u0026#39; =\u0026gt; 2, // maximum rows allowed, when reached the \u0026#34;new item\u0026#34; button will be hidden // allow reordering? \u0026#39;reorder\u0026#39; =\u0026gt; false, // hide up\u0026amp;down arrows next to each row (no reordering) \u0026#39;reorder\u0026#39; =\u0026gt; true, // show up\u0026amp;down arrows next to each row \u0026#39;reorder\u0026#39; =\u0026gt; \u0026#39;order\u0026#39;, // show arrows AND add a hidden subfield with that name (value gets updated when rows move) \u0026#39;reorder\u0026#39; =\u0026gt; [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;order\u0026#39;, \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;number\u0026#39;, \u0026#39;attributes\u0026#39; =\u0026gt; [\u0026#39;data-reorder-input\u0026#39; =\u0026gt; true]], // show arrows AND add a visible number subfield ], select2 系列 如同官方的敘述：\nWorks just like the SELECT field, but prettier.\nselect 系列基本上會把全部選項列出來，如果要多選還要按著 shift。 select2 系列看起來就比較美觀，是類似 dropdown 這樣： Slug Slug 看起來也蠻特殊的，可以在網頁直接把文字動態轉為符合網址的格式。 使用方式如下：\nCRUD::field(\u0026#39;name\u0026#39;); CRUD::addfield([ \u0026#39;name\u0026#39;=\u0026gt;\u0026#39;slug\u0026#39;, \u0026#39;target\u0026#39;=\u0026gt;\u0026#39;name\u0026#39;, \u0026#39;label\u0026#39;=\u0026gt;\u0026#39;Slug\u0026#39;, \u0026#39;type\u0026#39;=\u0026gt;\u0026#39;slug\u0026#39; ]); 效果會如下（是動態的，但這裡用圖片示意）： 如果不想要是動態的，也可以將他暫停掉：\nprotected function setupUpdateOperation() { $this-\u0026gt;setupCreateOperation(); // disable editing the slug when editing $this-\u0026gt;crud-\u0026gt;field(\u0026#39;slug\u0026#39;)-\u0026gt;target(\u0026#39;\u0026#39;)-\u0026gt;attributes([\u0026#39;readonly\u0026#39; =\u0026gt; \u0026#39;readonly\u0026#39;]); } Table Table 感覺也是工作上會常常用的。 使用 Table 的話，會允許 multiple input，並把這些 input value 存成 JSON。\n[ // Table \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;options\u0026#39;, \u0026#39;label\u0026#39; =\u0026gt; \u0026#39;Options\u0026#39;, \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;table\u0026#39;, \u0026#39;entity_singular\u0026#39; =\u0026gt; \u0026#39;option\u0026#39;, // used on the \u0026#34;Add X\u0026#34; button \u0026#39;columns\u0026#39; =\u0026gt; [ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;Name\u0026#39;, \u0026#39;desc\u0026#39; =\u0026gt; \u0026#39;Description\u0026#39;, \u0026#39;price\u0026#39; =\u0026gt; \u0026#39;Price\u0026#39; ], \u0026#39;max\u0026#39; =\u0026gt; 5, // maximum rows allowed in the table \u0026#39;min\u0026#39; =\u0026gt; 0, // minimum rows allowed in the table ], 做出來會如下圖： [!note] 記得要在 model 設定 casting。\nOverwriting Default Field Types Backpack 的 field types 通常都存在 resources/views/fields。\n如果需要修改已經存在的 field，不用特別去改 package，只需要在 /resources/views/vendor/backpack/crud/fields 新增一個有同樣名字的 view。Backpack 會優先確認那裡有沒有檔案，如果沒有檔案才去 load package。\n可以使用 php artisan backpack:field --from=field_name 來新增一個 field blade file，backpack 會幫忙新增。可以對新增完的檔案進行修改：\n{{-- number input --}} @include(\u0026#39;crud::fields.inc.wrapper_start\u0026#39;) \u0026lt;label\u0026gt;{!! $field[\u0026#39;label\u0026#39;] !!}\u0026lt;/label\u0026gt; @include(\u0026#39;crud::fields.inc.translatable_icon\u0026#39;) @if(isset($field[\u0026#39;prefix\u0026#39;]) || isset($field[\u0026#39;suffix\u0026#39;])) \u0026lt;div class=\u0026#34;input-group\u0026#34;\u0026gt; @endif @if(isset($field[\u0026#39;prefix\u0026#39;])) \u0026lt;div class=\u0026#34;input-group-prepend\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;input-group-text\u0026#34;\u0026gt;{!! $field[\u0026#39;prefix\u0026#39;] !!}\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; @endif \u0026lt;input type=\u0026#34;number\u0026#34; name=\u0026#34;{{ $field[\u0026#39;name\u0026#39;] }}\u0026#34; value=\u0026#34;{{ old_empty_or_null($field[\u0026#39;name\u0026#39;], \u0026#39;\u0026#39;) ?? $field[\u0026#39;value\u0026#39;] ?? $field[\u0026#39;default\u0026#39;] ?? \u0026#39;\u0026#39; }}\u0026#34; @include(\u0026#39;crud::fields.inc.attributes\u0026#39;) \u0026gt; @if(isset($field[\u0026#39;suffix\u0026#39;])) \u0026lt;div class=\u0026#34;input-group-append\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;input-group-text\u0026#34;\u0026gt;{!! $field[\u0026#39;suffix\u0026#39;] !!}\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; @endif @if(isset($field[\u0026#39;prefix\u0026#39;]) || isset($field[\u0026#39;suffix\u0026#39;])) \u0026lt;/div\u0026gt; @endif {{-- HINT --}} @if (isset($field[\u0026#39;hint\u0026#39;])) \u0026lt;p class=\u0026#34;help-block\u0026#34;\u0026gt;{!! $field[\u0026#39;hint\u0026#39;] !!}\u0026lt;/p\u0026gt; @endif Hello @include(\u0026#39;crud::fields.inc.wrapper_end\u0026#39;) 像我在 number field type 的最後面加了一個 Hello，雖然沒什麼意義，但可以看一下效果： Creating a Custom Field Type 也可以自己創建一個新的field type，可以用以下指令：\n// to create one using Backpack\\Generators, run: php artisan backpack:field new_field_name // alternatively, to create a new field similar an existing field, run: php artisan backpack:field new_field_name --from=old_field_name Field Defintion 可能會像：\n[ // Custom Field \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;address\u0026#39;, \u0026#39;label\u0026#39; =\u0026gt; \u0026#39;Home address\u0026#39;, \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;address\u0026#39; /// \u0026#39;view_namespace\u0026#39; =\u0026gt; \u0026#39;yourpackage\u0026#39; // use a custom namespace of your package to load views within a custom view folder. ], 當然，我們也可以自己編輯 blade file。在這個 custom field type，可以用幾個變數：\n$crud - all the CRUD Panel settings, options and variables; $entry - in the Update operation, the current entry being modified (the actual values); $field - all attributes that have been passed for this field; 結語 這篇文件蠻詳盡的介紹了 fields，從一開始介紹 attributes，到中間列出幾乎所有的 fields，最後介紹客製化。\n","date":"2023-05-19T18:11:57+08:00","image":"https://jyu1999.com/post/backpack03/0_hu10d21063a2d5df6ebb9f3142db7576d3_8853_120x120_fill_box_smart1_3.png","permalink":"https://jyu1999.com/post/backpack03/","title":"Laravel Backpack 初學者之路-03"},{"content":"第二天依然來看 backpack 的 text course: Advanced Features。 基本上是有蠻多 operations 和 features。 官方教學文檔有提到這些東西先看看就好，所以在這裡先以了解使用方式為主，不會深究具體的實現方式。\nOther Operations Show 這個 operation 是讓 admin 有一個網頁可以看一個 entry 裡面的詳細資料，比如說有些文章的 content 不會顯示在清單頁，但可以利用 show operation 做到檢視。 它會在 ListEntries View 新增一個 preview。\n如果是透過前一篇的指令 sail artisan backpack:crud tag 生成的 controller，內建就會包含 use \\Backpack\\CRUD\\app\\Http\\Controllers\\Operations\\ShowOperation;。如果沒有的話要加上這行才可以用 show operation。 然後可以用 sail artisan route:list 看一下怎麼到 preview 網頁，基本上是用 admin/article/{id}/show。\nHow to configure 預設是會列出所有在資料庫裡面的資訊，但如果不想要這麼多，可以客製化。 可以在 crudController 裡面放一個 setupShowOperation() 。 如果想要讓 preview 頁面顯示的東西、設定、順序都跟 ListEntries View 一樣，可以用以下指令：\nprotected function setupShowOperation() { $this-\u0026gt;setupListOperation(); } 當然，如同 setupListOperation() 一樣，如果想要更動顯示順序、設定，也是可以自己再另外寫，詳見官網。\nHow to add custom sections(aka. Widgets) 在 show 的頁面上，可以加入一些 widgets，像是卡片、圖表之類的。 可以使用預設的 widget type，也可以創建自己的 widgets。 Backpack 預設提供兩個可以放 widgets 的 section:\nbefore_content after_content 我們可以用以下官方提供的程式碼來試用看看 widget: public function setupShowOperation() { // dynamic data to render in the following widget $userCount = \\App\\Models\\User::count(); //add div row using \u0026#39;div\u0026#39; widget and make other widgets inside it to be in a row Widget::add()-\u0026gt;to(\u0026#39;before_content\u0026#39;)-\u0026gt;type(\u0026#39;div\u0026#39;)-\u0026gt;class(\u0026#39;row\u0026#39;)-\u0026gt;content([ //widget made using fluent syntax Widget::make() -\u0026gt;type(\u0026#39;progress\u0026#39;) -\u0026gt;class(\u0026#39;card border-0 text-white bg-primary\u0026#39;) -\u0026gt;progressClass(\u0026#39;progress-bar\u0026#39;) -\u0026gt;value($userCount) -\u0026gt;description(\u0026#39;Registered users.\u0026#39;) -\u0026gt;progress(100 * (int)$userCount / 1000) -\u0026gt;hint(1000 - $userCount . \u0026#39; more until next milestone.\u0026#39;), //widget made using the array definition Widget::make( [ \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;card\u0026#39;, \u0026#39;class\u0026#39; =\u0026gt; \u0026#39;card bg-dark text-white\u0026#39;, \u0026#39;wrapper\u0026#39; =\u0026gt; [\u0026#39;class\u0026#39; =\u0026gt; \u0026#39;col-sm-3 col-md-3\u0026#39;], \u0026#39;content\u0026#39; =\u0026gt; [ \u0026#39;header\u0026#39; =\u0026gt; \u0026#39;Example Widget\u0026#39;, \u0026#39;body\u0026#39; =\u0026gt; \u0026#39;Widget placed at \u0026#34;before_content\u0026#34; secion in same row\u0026#39;, ] ] ), ]); //you can also add Script \u0026amp; CSS to your page using \u0026#39;script\u0026#39; \u0026amp; \u0026#39;style\u0026#39; widget Widget::add()-\u0026gt;type(\u0026#39;script\u0026#39;)-\u0026gt;stack(\u0026#39;after_scripts\u0026#39;)-\u0026gt;content(\u0026#39;https://code.jquery.com/ui/1.12.0/jquery-ui.min.js\u0026#39;); Widget::add()-\u0026gt;type(\u0026#39;style\u0026#39;)-\u0026gt;stack(\u0026#39;after_styles\u0026#39;)-\u0026gt;content(\u0026#39;https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.0.0-beta.58/dist/themes/light.css\u0026#39;); } 在 Widget::add()-\u0026gt;to('before_content') 可以看到這邊使用了 before_content ，所以理論上 widget 會顯示在預設要顯示的東西之上。 同理可知，如果用 after_content，widget 就會在下面： How to overwrite 雖然預設的頁面看起來不錯，但我們可能仍想要更動 show 的邏輯。 目前頁面顯示的邏輯是寫在ShowOperation.php裡面，show()這個 method 而 EntityCrudController 是繼承了 ShowOperation 這個 trait，所以我們可以在 EntityCrudOperation 裡面自己寫一個 show() 就可以為不同的 entity 客製化顯示邏輯喔。 如官網範例：\nuse \\Backpack\\CRUD\\app\\Http\\Controllers\\Operations\\ShowOperation { show as traitShow; } public function show($id) { // custom logic before $content = $this-\u0026gt;traitShow($id); // custom logic after return $content; } Reorder 這個 operation 可以讓 admin 可以重新排列，或巢狀排列 entries。 Requirements 為了要使用 reorder，model 需要有幾個 integer fields，並預設值為零:\nparent_id -\u0026gt; 必須要是 nullable lft rgt depth Usage 首先必須要在資料庫加上上面提到的四個欄位。 在 entryCrudController 加上：\nprotected function setupReorderOperation(){ CRUD::set(\u0026#39;reorder.label\u0026#39;, \u0026#39;name\u0026#39;); CRUD::set(\u0026#39;reorder.max_level\u0026#39;, 2); } 這兩行可以：\n讓使用者可以使用 reorder operation 在 \u0026ldquo;add entry \u0026quot; 按鈕旁邊會出現一個 \u0026ldquo;Reorder\u0026rdquo; 按鈕 開啟到 Reorder 的 router 這時候看 route:list 會看到：\nGET|HEAD admin/tag/reorder .................... tag.reorder › Admin\\TagCrudController@reorder POST admin/tag/reorder ........... tag.save.reorder › Admin\\TagCrudController@saveReorder 所以輸入 url 就會到 reorder 的介面： 目前顯示在 reorder 介面的會是 entry 的 name。如果想要顯示其他東西可以把 'name' 改成自己想要顯示的 (e.g. 'slug') 數字 2 代表最大可以接受的深度，如果沒有限制的話，可以設為 0。\n此時可以進到 reorder 的頁面玩玩看，但玩完按 save 回到主頁之後，會發現什麼都沒有變。 原因是因為主頁還是用預設的排序方式，如果想要更改排序方式可以：\nprotected function setupListOperation() { CRUD::column(\u0026#39;created_at\u0026#39;); CRUD::column(\u0026#39;name\u0026#39;); CRUD::column(\u0026#39;slug\u0026#39;); CRUD::column(\u0026#39;price\u0026#39;)-\u0026gt;type(\u0026#39;number\u0026#39;); CRUD::column(\u0026#39;updated_at\u0026#39;); CRUD::setColumnDetails(\u0026#39;price\u0026#39;,[ \u0026#39;label\u0026#39;=\u0026gt;\u0026#39;Tag Price\u0026#39;, \u0026#39;prefix\u0026#39;=\u0026gt;\u0026#39;$\u0026#39; ]); CRUD::orderBy(\u0026#39;lft\u0026#39;); } 這樣就會按照 lft 排序～\n官方文件有提到，在 reorder 介面中同樣可以加入 widget，基本上是用和 show 一樣的方式。在這邊就不實作了。\n補充：lft and rgt 在實作的時候，我還蠻好奇 lft 和 rgt 到底是怎麼被算出來的。 稍微查了一下，nest entries 實際上就是一個 tree，backpack 會對對 tree 進行 preorder traversal（不過是改編版的）。然後算出 lft and rgt。 舉例來說，如果現在 nest entries 長這樣： ![[Pasted image 20230411121316.png|500]] 算出 lft and rgt 的步驟為：\n從 root(fourth tag) 開始，lft of fourth tag = 2（初始值為 2） 到 fourth tag 的第一個 child (fifth tag)，lft of fifth tag = 3 (2+1) 到 fifth tag 的第一個 child (third tag)，lft of third tag = 4 third tag 沒有 child，所以 rgt of third tag = 5 move back to the parent (fifth tag) fifth tag 的第二個 child (seventh tag)，lft of seventh tag = 6 seventh tag 沒有 child，所以 rgt of seventh tag = 7 move back to the parent (fifth tag) fifth tag 沒有其他 child 了，所以 rgt of seventh tag = 8 move back to the parent (fourth tag) 到 fourth tag 的第二個 child (first tag)，lft of first tag = 9 \u0026hellip;以此類推 最後求完會如下表：\nid name slug price parent_id lft rgt depth created_at updated_at 1 first tag firsttag 30 4 9 14 2 2023-04-11 01:20:01 2023-04-11 04:03:55 2 second tag secondtag 40 1 10 11 3 2023-04-11 01:20:13 2023-04-11 04:03:55 3 third tag thirdtag 50 5 4 5 3 2023-04-11 01:20:41 2023-04-11 04:03:55 4 fourth tag fourthtag 50 null 2 15 1 2023-04-11 03:51:11 2023-04-11 04:03:55 5 fifth tag fifthtag 70 4 3 8 2 2023-04-11 03:51:24 2023-04-11 04:03:55 6 sixth tag sixthtag 90 1 12 13 3 2023-04-11 04:03:31 2023-04-11 04:03:55 7 seventh tag seventhtag 90 5 6 7 3 2023-04-11 04:03:43 2023-04-11 04:03:55 然後如果要 print 出來的話，就用 lft and rgt 來重建原本的 tree：\n選擇 lft 最小的 node 作為 root（在這個例子中是 fourth tag）。 尋找 lft 值介於 root 的 lft 和 rgt 之間的 node，並且其 depth 比 root 多1。這些 node 將成為 root 的 child node（在這個例子中是 fifth tag 和 first tag）。 對於每個 child node，重複步驟 2，直到所有 node 都被訪問。 Revise Revise 可以讓 admin 去儲存、查看、取消對於一個 entries 的修改。 類似版本管理系統，admin 可以在頁面上看到所有的 change 和此次修改是誰做的。\nUsage 其實過程蠻簡單的，裝好、建好表就差不多了。 要先安裝這個 package。\ncomposer require backpack/revise-operation 然後建一個用來存修改的表：\ncp vendor/venturecraft/revisionable/src/migrations/2013_04_09_062329_create_revisions_table.php database/migrations/ \u0026amp;\u0026amp; php artisan migrate 然後在 model 裡面，新增一個 identifiableName() method，讓 admin 可以分辨不同的 entries(e.g. name, title\u0026hellip;)。 如果又用到別的 bootable trait，要去 override 掉：\nnamespace App\\Models; class Article extends Eloquent { use \\Backpack\\CRUD\\app\\Models\\Traits\\CrudTrait, \\Venturecraft\\Revisionable\\RevisionableTrait; public function identifiableName() { return $this-\u0026gt;name; } // If you are using another bootable trait // be sure to override the boot method in your model public static function boot() { parent::boot(); } } 最後，在 CrudController，使用 operation trait:\n\u0026lt;?php namespace App\\Http\\Controllers\\Admin; use Backpack\\CRUD\\app\\Http\\Controllers\\CrudController; class ArticleCrudController extends CrudController { use \\Backpack\\ReviseOperation\\ReviseOperation; 這樣就可以正常使用了！ 下表為 revision 表：\nid revisionable_type revisionable_id user_id key old_value new_value created_at updated_at 1 App\\Models\\Article 1 1 topic My first article My first article. haha 2023-04-11 05:03:18 2023-04-11 05:03:18 2 App\\Models\\Article 1 1 slug 1starticle 1starticle-haha 2023-04-11 05:03:18 2023-04-11 05:03:18 3 App\\Models\\Article 1 1 content This is my first article. This is my first article. and I want to do revision 2023-04-11 05:03:18 2023-04-11 05:03:18 官方文件上還列出另外三個 operations:\nClone BulkDelete BuldClone 但稍微看了一下，好像都是介紹用法而已，就不特別研究ㄌ。\n","date":"2023-05-19T18:05:21+08:00","image":"https://jyu1999.com/post/backpack02/0_hu10d21063a2d5df6ebb9f3142db7576d3_8853_120x120_fill_box_smart1_3.png","permalink":"https://jyu1999.com/post/backpack02/","title":"Laravel Backpack 初學者之路-02"},{"content":"What is Backpack? Backpack 是一個很多個 Laravel Packages 的集合，用來做客製化的 admin panels，可以讓 admin 登入並進行 CRUD 操作。 在前端的部分， Backpack 有著類似於 bootstrap 的設計（CoreUI theme），官方命名為 Backstrap。簡單來說，當我們在寫前端的時候，Backpack 裡面就有一些 HTML Blocks 可以直接套用。 在後端的部分，Backpack 也可以幫助使用者創建 CRUD Panels。\nInstallation 開始來試用一下 Laravel Backpack 雖然 Backpack 的版本跟的算緊，但在撰寫當下(2023/4/10) 只支援 Laravel 9（後來發現有支援 Laravel 10），因為不想變動本機的環境，所以我使用 Laravel sail 來建一個 container:\ncomposer create-project laravel/laravel backpackTest1 9 cd backpackTest1/ composer require laravel/sail --dev php artisan sail:install sail artisan migrate sail up （如果對 Laravel sail 不熟悉，可以使用本地端的）\n建完專案之後，開始安裝 backpack:\nsail composer require backpack/crud sail artisan backpack:install 裝的時候會問要不要建一個 admin 帳號，就先建一個起來吧～ 裝好之後，進到 http://localhost/admin/ 就會看到以下畫面。 輸入剛剛創建好的 admin 帳號之後，就可以進到 dashboard 了～\nCRUD 接著來看官方的 Text Course。 要用 CRUD 首先就要在資料庫建表，官方是推薦使用 laracasts/generators，看了一下 github 頁面，似乎是一個可以在 CLI 介面生成 migration file 的一些資訊。 但其實不裝應該也不會怎樣（吧）。\n# STEP 0. install a 3d party tool to generate migrations sail composer require --dev laracasts/generators sail composer require --dev backpack/generators # STEP 1. create a migration sail artisan make:migration:schema create_tags_table --model=0 --schema=\u0026#34;name:string:unique,slug:string:unique\u0026#34; sail artisan migrate # STEP 2. create a CRUD for it sail artisan backpack:crud tag #use singular, not plural 用上面的指令之後，會產生：\na migration file a model (app\\Models\\Tag.php) a request file, for form validation (app\\Http\\Requests\\TagCrudRequest.php) a controller file, where you can customize how the CrudPanel looks and feels (app\\Http\\Controllers\\Admin\\TagCrudController.php) a route, as a line inside routes/backpack/custom.php 此外，也會加入： a route inside routes/backpack/custom.php, pointing to that controller; a sidebar item inside resources/views/vendor/backpack/base/inc/sidebar_content.blade.php; 在這裡不會有 view 產生，因為在大部分使用 Backpack 的情況下，是不需要 custom views 的。所有的 custom code 都在 controller, model 或 request 裡面。\n建完之後，這時候把 url 改成 http://localhost/admin/tag 就會神奇的出現頁面了！ 稍微玩了一下，似乎是已經把 CRUD 都做好了。\n根據官方文件所說，我們暫時不用去管 migration, model, request，因為他們沒辦法客製化。唯一需要注意的是要看 model 有沒有正確的配置（e.g. db table, relationships, $fillable or $guarded ）。 目前我們只需要專注在 TagCrudController 這個檔案即可，大部分的邏輯操作都會在裡面\n在 controller 裡面有兩個 method：setupCreateOperation() and setupUpdateOperation()，是用來定義我們要讓 admin 看到什麼 field。\nprotected function setupCreateOperation() { CRUD::setValidation(TagRequest::class); CRUD::field(\u0026#39;name\u0026#39;); CRUD::field(\u0026#39;slug\u0026#39;); } 像現在裡面只有 name 和 slug，如果沒有指定 type 的話預設是 text。 在官方教學有提到，一點典型的 field 需要至少有三個要素：\nname - the attribute (column in the database), which will also become the name of the input; type - the kind of field we\u0026rsquo;d like to use (text, number, select2, etc); label - the human-readable label for the input (will be generated from name if not given); e.g. Add a field \u0026ldquo;price\u0026rdquo; 如果我們想要為每一個 tag 新增一個 price 要怎麼做呢？ 首先要在資料庫 tag table 裡面新增一個 column: price。 然後修改setupCreateOperation() and setupUpdateOperation()：\nprotected function setupListOperation() { CRUD::column(\u0026#39;created_at\u0026#39;); CRUD::column(\u0026#39;name\u0026#39;); CRUD::column(\u0026#39;slug\u0026#39;); CRUD::column(\u0026#39;price\u0026#39;)-\u0026gt;type(\u0026#39;number\u0026#39;); // CRUD::addColumn([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;price\u0026#39;, \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;number\u0026#39;]); CRUD::column(\u0026#39;updated_at\u0026#39;); } protected function setupCreateOperation() { CRUD::setValidation(TagRequest::class); CRUD::field(\u0026#39;name\u0026#39;); CRUD::field(\u0026#39;slug\u0026#39;); CRUD::field(\u0026#39;price\u0026#39;)-\u0026gt;type(\u0026#39;number\u0026#39;); // CRUD::addField([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;price\u0026#39;, \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;number\u0026#39;])); } 在 table 上和新增頁，就會出現 price 了～\nArticle Model 官網上有簡單提到建另一個 model Article，並和 tag 建立多對多關係。 來試著實作看看。 首先一樣來產生 article 相關的檔案：\n# STEP 1. create a migration sail artisan make:migration:schema create_articles_table --model=0 --schema=\u0026#34;topic:string:unique,slug:string:unique,content:text\u0026#34; sail artisan migrate # STEP 2. create a CRUD for it sail artisan backpack:crud article #use singular, not plural 然後建一個 pivot 表：\nsail artisan make:migration create_articles_tags_table public function up() { Schema::create(\u0026#39;articles_tags\u0026#39;, function (Blueprint $table) { $table-\u0026gt;id(); $table-\u0026gt;unsignedBiginteger(\u0026#39;article_id\u0026#39;)-\u0026gt;unsigned(); $table-\u0026gt;unsignedBiginteger(\u0026#39;tag_id\u0026#39;)-\u0026gt;unsigned(); $table-\u0026gt;foreign(\u0026#39;article_id\u0026#39;)-\u0026gt;references(\u0026#39;id\u0026#39;) -\u0026gt;on(\u0026#39;articles\u0026#39;)-\u0026gt;onDelete(\u0026#39;cascade\u0026#39;); $table-\u0026gt;foreign(\u0026#39;tag_id\u0026#39;)-\u0026gt;references(\u0026#39;id\u0026#39;) -\u0026gt;on(\u0026#39;tags\u0026#39;)-\u0026gt;onDelete(\u0026#39;cascade\u0026#39;); $table-\u0026gt;timestamps(); }); } 然後依照剛剛對 tag 的步驟，對 article 做一樣的事情\nprotected function setupListOperation() { CRUD::column(\u0026#39;created_at\u0026#39;); CRUD::column(\u0026#39;topic\u0026#39;); CRUD::column(\u0026#39;slug\u0026#39;); CRUD::column(\u0026#39;updated_at\u0026#39;); } protected function setupCreateOperation() { CRUD::setValidation(ArticleRequest::class); CRUD::field(\u0026#39;topic\u0026#39;); CRUD::field(\u0026#39;slug\u0026#39;); CRUD::field(\u0026#39;content\u0026#39;); CRUD::field(\u0026#39;slug\u0026#39;); } 在 tagCrudController 新增下拉式選單：\nprotected function setupCreateOperation() { CRUD::setValidation(TagRequest::class); CRUD::field(\u0026#39;name\u0026#39;); CRUD::field(\u0026#39;slug\u0026#39;); CRUD::field(\u0026#39;price\u0026#39;)-\u0026gt;type(\u0026#39;number\u0026#39;); CRUD::addField([ \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;select2_multiple\u0026#39;, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;articles\u0026#39;, // the relationship name in your Model \u0026#39;entity\u0026#39; =\u0026gt; \u0026#39;articles\u0026#39;, // the relationship name in your Model \u0026#39;attribute\u0026#39; =\u0026gt; \u0026#39;topic\u0026#39;, // attribute on Article that is shown to admin \u0026#39;pivot\u0026#39; =\u0026gt; true, // on create\u0026amp;update, do you need to add/delete pivot table entries? ]); } 接著在 http://localhost/admin/article 隨便新增幾個文章，最後會做出像這樣的效果： 有需要的話，也可以在 articleCrudController 裡面也加入 tags，我自己有做，但在這裡就不演示。\nColumns 在 backpack 裡面提供了很多 column，可以在官網查詢 我們也可以在 setupListOperation() 裡面，為某個 column 設定細節：\nprotected function setupListOperation() { CRUD::column(\u0026#39;created_at\u0026#39;); CRUD::column(\u0026#39;name\u0026#39;); CRUD::column(\u0026#39;slug\u0026#39;); CRUD::column(\u0026#39;price\u0026#39;)-\u0026gt;type(\u0026#39;number\u0026#39;); CRUD::column(\u0026#39;updated_at\u0026#39;); CRUD::setColumnDetails(\u0026#39;price\u0026#39;,[ \u0026#39;label\u0026#39;=\u0026gt;\u0026#39;Tag Price\u0026#39;, \u0026#39;prefix\u0026#39;=\u0026gt;\u0026#39;$\u0026#39; ]); } 如此，我的 price 欄位會有微妙的變化XD 結語 今天稍微介紹了 Backpack 的基本，和最簡單的用法。 之後會再介紹如何新增 filter 和 button 之類的東西。\n","date":"2023-05-19T13:34:41+08:00","image":"https://jyu1999.com/post/backpack01/0_hu10d21063a2d5df6ebb9f3142db7576d3_8853_120x120_fill_box_smart1_3.png","permalink":"https://jyu1999.com/post/backpack01/","title":"Laravel Backpack 初學者之路-01"},{"content":"到 Setting 的 Deployment 新增（+）一個 Server，Server 名字隨便取。\nType 選擇 SFTP，Root path 選擇要上傳檔案的位置。\n接著設定路徑，如果 Root Path 有設定好的話 Deployment path 就直接 / 即可。\n在專案上點右鍵，選擇 Deployment \u0026gt; Upload to newB 即可上傳\n若是初次上傳記得要下 bundle install、db:create、db:migrate。\n如果要設定只上傳有修改過的檔案：\n這樣就會在存檔的時候自動上傳。\n要啟 server 的話可以：（如果是已經部署好的專案就不用啟 Server ㄌ～）\nbin/rails server -b=0.0.0.0 -p=3000 就可以在指定 ip 的 3000 port 讀取到網站了～㈷\n如果要搜尋更多設定，建議以 phpstorm 為關鍵字去搜，Rubymine 比較搜不到東西🫠 ","date":"2023-05-19T12:32:22+08:00","image":"https://jyu1999.com/post/rubymine_sftp/0_hu0c1f11c072218b2f868afe9cc57a6a5d_2064333_120x120_fill_box_smart1_3.png","permalink":"https://jyu1999.com/post/rubymine_sftp/","title":"Rubymine 透過 SFTP 自動同步 Server 檔案"},{"content":" 這是我自己學習後端的路程，和使用到的一些資源，以工具為主。\n語言/框架以 PHP/Laravel 為主，如果你是學其他語言的，自己代換即可。差異不大。\n在某些檔案中，我會註明最好先學什麼，再繼續進行下去。但也沒有絕對的先後順序，端看個人學習狀態。\n每個 Section 後面我會標完全零經驗者大概要花多久完成該 Section。\n我提供的資源（網站/課程/影片/書籍），不一定適用於所有人。建議大家從我提供的資源中，找出一些關鍵字，去搜尋對自己最有幫助的資源。\n完成到 Sec. 4 可以嘗試求職，完成 Sec. 5 去找工作「可能」會比較穩，但還是依公司型態和個人背景而定，沒有絕對。\nSec. 0 在開始之前 (Est. 1 Week) 😄 環境設置： OS: Linux or MacOS，不建議 Windows。你也可以開一台 Host，直接從純 CLI 介面開始。 Database: MySQL or Mariadb or PostgreSQL Webserver: Nginx(推) or Apache Language: PHP or others 😀 工具安裝（自己選擇要裝什麼） texteditor: vscode or Neovim or phpstorm\n進框架前，用什麼都可以。進框架後建議用 phpStorm。\nGit GUI: sourcetree\n這個不一定要裝，看個人。\nDatabase GUI: tableplus, datagrip\n這個也不一定要裝，但裝了之後，看 table 會比較好看一點。\nSec. 1 (Est. 2.5~3.5 Month) 初學者安裝完以上的東西應該已經心力交瘁，甚至重灌好幾次，但接下來才是挑戰的開始\u0026hellip; 以下四個基本上是後端工程師的必備技能。\n🤨 PHP Learning Path 用來寫後端的語言，沒什麼好說的\n😗 Git Learning Path 用來版本控制，每個工程師都該會\n😶 HTML \u0026amp; CSS Learning Path 後端基本上還是要會「看得懂」前端。 網路上相關資源非常多，這裡就不列出資源。 要特別注意的是，後端不用特別在意切版，只要對 HTML tag, attribute, flexbox, grid 等稍微有概念即可。 如果有意想要找全端工作的話，這部份可能就要略為多花一些時間了。\n😯 (Basic) Database Learning Path 跟資料庫互動也是一定要會的，不過這裡只單純指 sql 語法，還不用去優化效率和容量。\n😲 Stop to Practice! 看完以上幾個，可以先作一個小作品出來。像是留言板、TodoList 之類的 並嘗試在此作品中用到以下概念：\nSession/Cookie MVC CRUD OOP SQL/HTML Injection Validation 約定式提交 Sec. 2 (Est. 2~2.5 Month) 完成以上的路程，對後端也有一定的認識了。 接著我們進到稍微複雜一點的地帶\u0026hellip;\n🫤 Javascript Learning Path 主要集中在 DOM 的部分，這裡大概知道 DOM 會怎麼跟 HTML 做互動即可。沒空的話，詳細的 JS 概念（e.g. hoisting, callstack)可以不用了解。 有空的話當然就去把 JS 概念補一補～\n😵‍💫 Laravel Learning Path PHP 的框架，藉由 Convention 讓工程師的溝通協作更順暢，也不用擔心架構。\nSec. 3 (Est. 2~3 Month) 學完 Sec. 2，對於本地端開發應該已經熟悉了。 不過後端要會怎麼把網站 Deploy 到 Server 上。\n😨 Linux Learning Path 學完 Laravel 應該就具備基礎網頁製作的能力，接下來就是要把網頁上 Server。不過在上 Server 之前最好徹底熟悉一下 Linux，否則會不斷搞砸、不斷重啟、然後還不知道問題在哪\u0026hellip; 而且 Linux 也跟系統安全性息息相關，千萬不要隨意略過。 在學 Linux 的同時，也一併把 vim 學起來吧～\n🥺 Deploy Learning Path 再來要先知道如何把辛苦做的網站部署到 Host 上，並熟悉其原理。當然可以只看著教學一步步做，不管背後發生了什麼。但缺點就是發生了問題，也很難 debug\u0026hellip;\n😥 (Basic) API Learning Path 基礎的 API 以 RESTful 為主，且先不用管安全性、認證之類的東西。\nStop to Practice! 到這邊可以嘗試去買一個網域，連接到自己的 cloud host，並在 cloud host 上部署專案，讓別人可以 call api 取得資料。 你可能需要了解 Postman 使用、SSL、DNS、前後端分離等等概念。也需要了解一些常用的功能，包含但不限於上傳檔案、Validation、Cache 機制等等。\n嘗試求職 \u0026amp; 想想未來方向 如果你的目標是放在 junior 後端工程師的話，可能要考慮一下是否要繼續往下學，還是要先找工作了。就我的求職經驗來說，下面的內容對於 junior 後端工程師來說，是較少遇到的。\n如果要繼續學習的話，可能要思考一下自己想去的公司種類或職業別是什麼。如果公司以接案為主的話，你可能需要多熟悉網頁框架（Laravel, Django, RoR\u0026hellip;）。如果是產品公司的話，DevOps、架構師、後端工程師\u0026hellip;都是潛在的發展方向。\n建議是花多一些時間在思考這個，不然之後學習會愈學愈迷惘。\nSec. 4 🥶Docker Learning Path Docker 是一個可以幫助個人和團隊省下不少時間的工具，簡單來說就是將 application 和其所有的相依元件打包。 不僅很多公司會要求應徵者有使用 docker 的經驗，在 Stack Overflow 2022 的問卷調查中，docker 和 npm 可以說是在 other tool 類別裡面稱霸了。\n以下僅為草稿，期待後續我繼續往下走的時候更新。\nTesting Learning Path CI/CD Learning Path Sec. 5 進階 上面的路程基本上都是以「會使用」工具為主，到這邊開始會需要深入去探討安全性、效能相關的問題\nAlgorithm Learning Path (Advanced) Database Learning Path (Advanced) API Learning Path ","date":"2023-05-18T23:37:13+08:00","image":"https://jyu1999.com/post/backend_learning_path_jyu/1_hude5521f0826f80ff158c518f2b49a739_1591559_120x120_fill_q75_box_smart1.jpg","permalink":"https://jyu1999.com/post/backend_learning_path_jyu/","title":"JYu's Backend Learning Path"},{"content":"（本文同步更新在 vocus 和 medium 上）\n嗨大家好，我是結語 JYu。\n開始撰寫這個系列的時間是 2023 四月，也是我在好想工作室 backend camp 培訓的倒數一個月，想說可以分享一些心得，給對轉職為後端工程師的人參考。\n【好想工作室 — 後端 (backend Camp)培訓心得（一）：好想工作室簡介】：簡單介紹好想工作室。\n【好想工作室 — 後端 (backend Camp)培訓心得（二）：backend camp 在幹嘛】：會講後端培訓的點點滴滴。\n【好想工作室 — 後端 (backend Camp)培訓心得（三）：我好想進來好想】：會給想進 backend camp 的一些建議。\n【好想工作室 — 後端 (backend Camp)培訓心得（四）：我快崩潰了，怎麼辦？】：會講學員的心態管理。\n➡️【好想工作室 — 後端 (backend Camp)培訓心得（五）：這麼多東西，要怎麼學最有效率？】：會講學員的學習技巧。\n【好想工作室 — 後端 (backend Camp)培訓心得（六）：我好想要錢（找工作）】：會講我自己的求職心得。等我找到工作後（應該會）再寫\n本系列文章純以我的觀察和想法為出發點，不一定就是實際狀況，也不帶任何批判。\n如果覺得資訊對你有用的話，不妨按下方拍手鼓勵一下我喔！\n然後我都是想到什麼就寫什麼，難免會有沒有提及到的，如果你有任何疑問，歡迎寄信至 jk29666338@gmail.com 來詢問我。\n好，廢話都講完了，那就讓我們開始吧！\n前言 每個人可能都有自己學習的模式，但如果你初來乍到，你可能對如何學習後端技術或語言會感到很困惑。\n在這裡我提出我自己學習的方式，供初學者參考。\n當然還是建議大家要多多探索，找尋自己學後端最舒服的姿勢。\n基礎知識和用法的 tradeoff 如果你有看過我前面四篇文章的話，應該不難發現我非常強調「基礎知識」。\n什麼是基礎知識？我個人認為所謂基礎知識就是那些無論工具、語言怎麼換，都放諸四海皆準的東西。\n例如，在網站框架有一個重要的概念叫做 MVC 架構，這個 MVC 架構在各個後端語言框架都通用，只是有時候名字和實作方式會略有不同而已。 因此，MVC 架構就是屬於基礎知識，而特定語言如何實作 MVC 架構就不是基礎知識。\n同理，對於後端來說，網路知識（HTTP, IP, TCP/UDP…）、基礎資結演算法（時間複雜度、BFS、DFS…）、sql 原理（B+ Tree, 正規化…）、Linux OS、git 等等都算是基礎知識。\n但聰明的你應該不難想到，如果要把基礎知識都學完，才開始學習實際應用，顯然是不切實際的。可能從你兒子剛會叫爸爸，到你孫子已經成為後端工程師，你都還沒成功轉職。\n沒有公司會要一個只有概念，但沒辦法透過實作來顯示自己有概念的工程師的。\n所以要怎麼辦？完全不管基礎知識嗎？\n如果你正在學習，不要專注在解決問題本身 是的，你沒看錯。\n我其實不鼓勵大家隨機挑選基礎知識來學習，因為這樣顯然違背了我第一篇文章所提到，自學的精髓之一：挑真正對你有用的東西來學。\n什麼意思？上面不是說基礎知識放諸四海皆準嗎？怎麼這裡又說基礎知識對我沒用了？\n沒錯，基礎知識是具有「通用性」，但卻不代表它「會用到」。\n假設你研究演算法研究的非常深入，把各種奇形怪狀、偏門的演算法研究透徹，但現實是，一般企業根本就不會用到這麼多演算法。\n所以最好學習基礎知識的情境有兩個：\n你正在研究用法：你可能學到框架裡面有一個好用的 function 可以 call，這時候最好了解一下其底層是怎麼實作的。另一種可能是你用到語言中幫你啟好的 development server (e.g. laravel 裡面的 php artisan serve)，那你最好也去了解一下怎麼自己架 server。 你遇到 bug：基本上你看到 bug 就要特別小心了，除非你是純粹失誤，不然有可能就是你基礎知識不熟。像 Laravel 裡面的 model，預設不允許 mass assignment，為什麼？或是 Laravel 的表單需要放入一個 CSRF Token，為什麼？如果是為了安全性，那有沒有其他方式能增加安全性？ 簡單來說，在實作或除錯的過程中，稍微解析一下問題，多去思考其原理，然後保持好奇，看有沒有其他作法能達到相同的效果。不要急著把問題解掉就直接下一步了。\n知道去哪裡查用法就好 初學者常常會把所有的用法都寫在自己的筆記裡面，但我自己覺得沒有必要。\n一來很花時間，不僅需要紀錄，也需要整理。有時候要找的時候也未必找的到。\n二來有些用法可能會隨著版本迭代而有所不同。\n所以我推薦大家真的要記筆記的話，記「關鍵字」就好。假如你在學習 PHP 物件導向，那你筆記裡面只需要記下 Access Modifiers, Inheritance, Traits 等等關鍵字，然後記下可能會有答案的網站。這樣其實就夠了。\n如何判斷要不要繼續往下挖？ 假設你按照我上面的方法，可能你有一天會遇到一個 bug，這個 bug 牽扯到的基本知識超級多，涵蓋作業系統、語言特定、web server 架設等等。等於你解這個 bug 並學習背後的基礎原理，可能一個月就不見了。\n在這裡我的建議和上一篇文章判斷前輩的建議的方式一樣，就是要「深入了解建議/題目的內容以及用意」。\n也就是說，你可以看看類似的 bug 你是不是碰到好幾次了？如果已經碰到好幾次那可能真的是你有所欠缺，就趕快補上吧！\n但如果你跟這個 bug 才初次見面，剛玩完破冰遊戲，彼此還不熟悉的狀況，那你可以稍微評估一下背後原理是否會需要花很多時間了解，如果需要很多時間的話就先略過吧！\n爭議題：該不該跟著教學影片實作？ 曾經我有跟某位後端學員討論過這個問題，在這裡直接說我的答案吧：要，也不要。\n通常會遇到這個問題是長時間的影片實作，畢竟影片如果不到五分鐘，你做不做根本沒差。\n遇到這種影片，我通常就會看兩次。不過我第一次一定是不會跟著實作的。\n原因有二：\n影片內容未必對我有用：影片就是這樣，如果不是全部看完很難確認到底會不會學到自己想學的東西。如果我花費大量時間跟著實作，到一半才發現影片內容根本不符合我預期，不是很虧ㄇ 專心在理解：邊看影片邊做，有時候會讓人沒辦法去理解作者為什麼要這樣做，或聽清楚作者到底講了什麼，因為光是要跟上作者的打字速度就要卯足全力了。相反，如果完全不實作，就能把 100% 心力放在作者到底講了什麼，為什麼要這樣做。 第二次看影片的時候，我就會跟著作者實作，看實作起來會不會有什麼問題。甚至第一次看的夠清楚的話，搞不好也可以試著自己從頭開始做做看，如果遇到 bug 再回去看作者怎麼做，學習效果更佳！\n你就跟我們講一下嘛 最後，還是要提一下第二篇有提到的「主動分享」。\n比如說，我有時候會在 slack 跟同儕們分享剛剛的新發現。在撰寫的時候，我就會發現有些地方我講的並不是這麼順，我就會再額外去找資料，增強我自己的理解。\n不只是這樣，在 slack 丟出來，看到你分享的人，可能會額外提出一些疑問，這時候你不就又有新的東西可以研究嗎！\n也不用特別害怕講錯，反正你只是分享自己的理解，也沒有強迫灌輸別人你是正確的。況且，mentor 通常也會看到你的分享，如果真的有錯他（可能）也會幫你矯正一下，所以就大膽分享吧～\n謎之音：常常分享 mentor 就會覺得你比較認真？\n也不只是所學可以丟出來，我也鼓勵把一些 bug 丟出來討論。\n但當然不是每次遇到 bug，就直接把 error message 丟到群組啦。這樣真的太北爛了，小心被霸凌（X\n如果你要丟 bug 到群組討論，最好是附上以下敘述：\n你現在想做什麼功能？ error message 是什麼？ 你個人的推論是什麼？ 你試過哪些解決方法？試了之後 error message 有沒有變？ 為什麼要附上以上敘述，除了更方便別人 debug 之外，也才有**「討論」**的空間。\n比如說，mentor 發現你的推論很不合理，正常遇到這個狀況會是 C 出問題，而你卻說可能是 A or B 出問題，mentor 就能給你反饋。\n又比如說，你查詢到的解答很奇怪，根本不是解決這個問題所需要的。那很可能就是你欠缺的是「關鍵字」或「google 能力」，其他人就可以針對這個問題提出他們認為合理的關鍵字。\n總而言之，如果可以的話就多多分享吧！也要記得，你分享的目的只是為了讓自己變得更好，而不是真的要教給別人什麼，所以不用害怕說錯什麼～\n本篇分享了我認為身為後端學員，有效率的一些學習方式。如果有想到其他的我再補（有時間的話）。\n其實都蠻樸實無華的，畢竟學習本來就不會有捷徑，只有 chatgpt（X\n當然，如果你是現役或已畢業後端學員，歡迎跟我分享你親測有效的學習方式！\n","date":"2023-05-18T19:18:20+08:00","image":"https://jyu1999.com/post/goodidea-mind-5/4_hu4e44a9238dd9439c985217ad54ea95d7_57691_120x120_fill_box_smart1_3.png","permalink":"https://jyu1999.com/post/goodidea-mind-5/","title":"好想工作室 — 後端 (Backend Camp) 培訓心得（五）：這麼多東西，要怎麼學最有效率？"},{"content":"（本文同步更新在 vocus 和 medium 上）\n嗨大家好，我是結語 JYu。\n開始撰寫這個系列的時間是 2023 四月，也是我在好想工作室 backend camp 培訓的倒數一個月，想說可以分享一些心得，給對轉職為後端工程師的人參考。\n【好想工作室 — 後端 (backend Camp)培訓心得（一）：好想工作室簡介】：簡單介紹好想工作室。\n【好想工作室 — 後端 (backend Camp)培訓心得（二）：backend camp 在幹嘛】：會講後端培訓的點點滴滴。\n【好想工作室 — 後端 (backend Camp)培訓心得（三）：我好想進來好想】：會給想進 backend camp 的一些建議。\n➡️【好想工作室 — 後端 (backend Camp)培訓心得（四）：我快崩潰了，怎麼辦？】：會講學員的心態管理。\n【好想工作室 — 後端 (backend Camp)培訓心得（五）：這麼多東西，要怎麼學最有效率？】：會講學員的學習技巧。\n【好想工作室 — 後端 (backend Camp)培訓心得（六）：我好想要錢（找工作）】：會講我自己的求職心得。等我找到工作後（應該會）再寫\n本系列文章純以我的觀察和想法為出發點，不一定就是實際狀況，也不帶任何批判。\n如果覺得資訊對你有用的話，不妨按下方拍手鼓勵一下我喔！\n然後我都是想到什麼就寫什麼，難免會有沒有提及到的，如果你有任何疑問，歡迎寄信至 jk29666338@gmail.com 來詢問我。\n好，廢話都講完了，那就讓我們開始吧！\n前言 寫這篇文章的用意，是因為在工作室培訓的時候，難免會遇到很多挫折。\n在 bug 解不出來，難免會對自己產生懷疑。尤其看到別人都解出來，彷彿只有自己停在原地的時候。\n在第二篇提到夥伴的時候，我有說到有些人真的是背水一戰，尤其是上有老母，下有妻小的人，壓力會特別大。\n而在這麼緊繃的狀況下，特別容易情緒低落，心理影響生理，產生一些負面的想法。\n這篇文章就是寫給有類似情況的學員看的，但如果你沒有這種狀況，也可以考慮閱讀這篇文章。畢竟預防勝於治療。\n但也不要對這篇文章有錯誤的期待，絕對不可能看完這篇文章就豁然開朗。這篇文章頂多是提供給你一些過來人的經驗，和思考模式。\n警語 很明顯的，我不是心理師或醫生。\n每個人的心思都很細膩，情緒低落的原因也是百百種。\n如果你真的已經出現一些明顯的症狀，建議你直接去求助專業的心理師或醫生。\n預防勝於治療 在培訓的過程中，很常會產生無力感，具體來說是一種「我知道現在應該要幹嘛，我也有時間做，但我不知道要幹嘛」的弔詭感覺。\n很像是去問大考前的學生，他們的準備狀況。真的會有很多學生覺得自己都已經讀完了，沒什麼好讀的了。\n遇到這種狀況就要特別小心了，這種狀況常常就是惡性循環的開始。\n因為你不知道要幹嘛，你可能動力就比較低，然後進度就很慢。但隨著時間推移又出現了更多東西要學，壓力又更大。\n99% 的學員心理應該都曾冒出過這句話：\n明明我已經很認真了，為什麼還是感覺要學的東西完全沒有減少？\n會有這個想法其實是很正常的，因為一開始你的心裡面可能只有程式語言，或操作資料庫。\n隨著你逐漸成長，你會發現只會這兩個是遠遠不夠的。後端領域包山包海，從 web server 到 cloud host，甚至資料庫還有設計規劃的部分。\n但是，你會發現到這些不足，正是因為你有所成長。\n因此，建議大家多關注在自己已經學會的部分，而非還有多少需要學習。\n不要讓前輩的建議害到你 進到工作室會有很多的前輩，如果你問他們問題的話，很有可能他們會說：「我覺得你可以研究這個看看。」\n然後這時候身為學員你的，心中可能就會 OS：「阿我現在這個都還沒學會，上次另一個前輩叫我學那個，你又叫我學另外一個，所以我現在到底要怎樣？」\n不要誤會，我不是在臭這些前輩，這些前輩一定都是想著讓你更好，而提出建議的。\n但身為學員的你，卻難免會受到這些建議影響。那該怎麼做呢？\n另外一個例子，是工作室可能會舉辦一些挑戰賽，然後「建議」特定 camp 的人參加。\n這些挑戰賽的用意都是好的，如果認真參與的話也一定可以學到很多東西。\n但正常參加挑戰賽的話，學習順序應該是：\n解題 → 遇到問題 -\u0026gt; google -\u0026gt; 發現自己不足 → 補足基礎知識 -\u0026gt; 解決問題 -\u0026gt; 解下一題\n然而，因為挑戰賽題目一題接一題，可能上一題還沒完成下一題就出來了，在這種狀況下，有些人會略過了「補足基礎知識」這個最重要最重要的步驟。\n最後，因為都沒有補足基礎知識，變成挑戰賽淪為 google 訓練賽，看誰比較會搜尋 bug。\n最好的比喻方式就是，叫一群高一新生，直接開始做可以 open book 的模擬學測。完全沒有任何一丁點基礎知識的他們，只能拼命的看書裡面有沒有一模一樣的題目，想辦法把答案填上去。但填完還是對題目一知半解，下次遇到類似的問題還是不會。\n但我要再次強調，這絕對不是挑戰賽的問題。而是學員沒有自己想清楚**「參與形式」**的問題。\n所以，講了這麼多，到底要怎麼辦？\n講到爛大街的獨立思考 沒錯，答案很爛，就是獨立思考。\n工作室任何前輩給你的建議，都不是聖旨，也不是叫你現在就要做。僅僅是提供給你一個新的想法。\n因此，不管聽到任何建議、參加任何挑戰賽之前或是正在參與挑戰賽，可以用以下方向進行思考：\n深入了解建議/題目的內容以及用意：首先你要知道這個建議可以帶來哪些效益，CP 值是否真的高？有沒有其他人給過你同樣的建議了？如果有超過三個人都給你一模一樣的建議，那你真的得好好考慮一下。此外，你也可以評估一下執行這個建議所需要花費的時間。有些建議聽起來很恐怖，但實際上一兩天就可以完成。我個人認為如果這個建議三天內可以達成，那做做看也無傷大雅。 對題目也是一樣，你要知道解完這個題目，你大概可以獲得什麼。是否在很多地方都有看過類似的題目了？這個題目能否在三天內完成？ 這個跟我的目標有一致嗎：雖然是後端工程師的培訓，但每個人想做的也可能不一樣。有些人可能對全端比較有興趣，那可能要專注在框架；有些人支持前後端分離，那可能要專注在 API 開發；有些人喜歡雲端服務，那可能要好好學習 AWS。同時，每家公司後端工程師職位，所需要的技能也都略有不同。所以，聽到建議之後，好好想想這是否真的是你想學的 / 你求職會用到的，再決定要不要行動。 審視自己現在的狀態：有時候可能家裡剛好有事，或是最近已經覺得負荷很大了，最好是不要貿然加入新的東西。反之，如果最近狀態很好，心情愉悅，就可以考慮採行建議。 覆盤：你做完一個題目，真的有感覺到自己變強嗎？真的有感覺自己學到什麼新知識嗎？要檢驗這點最好的方法，就是跟你的同儕們的分享你在這次做題過程中的所學。要注意是「所學」而不是「你怎麼解的」。對我來說，所學是可以複製、應用在多種情況的；而「解法」只能針對特定狀況，所以只要題目變一下你就不會了。也就是我上面說的，你是否有透過題目找到自己的不足，並補足基礎知識呢？若答案都是否，你可能要好好調整一下。 總而言之，千萬不要被簡單一句「我們現在是在模擬工作的情況」就貿然把自己的時間投入在任何事情上。\n就如同上面的舉例，實力夠的人，做模擬考才有意義。\n如果我已經陷入低潮了呢… 低潮真的是難免，我從開始學程式到現在將近三年的時間，有兩次真的是差點撐不下去，甚至考慮要重考了。\n而我也必須說，解鈴尚需繫鈴人，只有你自己想通了，才能讓自己走出來。\n不過我們還是可以嘗試一些簡單的作法：\n轉移注意力：如果你一個問題真的卡了很久，就暫時 let it go 吧，先研究其他領域。或是真的受不了的話，也可以跟 mentor 請一兩天的假，出去散散心。學程式是長期的事情。關於這個我就有親身經驗，曾經有一個 coding 題目我解了整整一天都解不出來，看時間很晚了，就決定放棄然後上床睡覺。在床上跟室友喇賽的時候，突然靈光一個乍現，跳下床，不到五分鐘就把問題解掉了。所以千萬不要覺得短暫的迴避一下會怎樣，這個短暫的迴避不僅能讓你充電，面對更久遠的挑戰，搞不好還會給你帶了意外的靈感喔 ：） 累積微小成就感：我認為自信心對一個人是非常重要的，當你相信你一天就可以把事情做完，你就很有可能一天就做完。跟《原子習慣》裡面提到的「自我認同」的概念很像。反之，當你開始覺得「我一定是廢物」，你就很有可能如你所想的逐漸墮落。所以，當你低潮的時候，不妨就先挑一些簡單的事情做，像是練打字、學習 linux 指令等等，這些事情難度不高，但會逐步建立你個成就感，讓你覺得你是個每天都有固定產值的人。 專注在現在：低潮或是在胡思亂想的時候，可以多問問自己，所以「現在」、「此時此刻」、「這一分這一秒」，我能做的事情是什麼？80% 以上的狀況，你唯一能做的就是專注在眼前這個問題，想盡一切辦法把他解決。那既然只有這件事情能做，就什麼都不用擔心了不是嗎？當然有可能你得出的答案是暫時「鬆一下」，那也無傷大雅啦 XD 這篇文章大概到這裡了，如果我有想到什麼再補充。\n如果你覺得有什麼更好的建議，給陷入低潮的朋友們，歡迎來跟我分享XD\n如果你是現在正在低潮的學員，那就好好加油吧！拍拍🙌\n下一篇：【好想工作室 — 後端 (backend Camp)培訓心得（五）：這麼多東西，要怎麼學最有效率？】：會講學員的學習技巧。\n","date":"2023-05-18T19:18:13+08:00","image":"https://jyu1999.com/post/goodidea-mind-4/4_hu4e44a9238dd9439c985217ad54ea95d7_57691_120x120_fill_box_smart1_3.png","permalink":"https://jyu1999.com/post/goodidea-mind-4/","title":"好想工作室 — 後端 (Backend Camp) 培訓心得（四）：我快崩潰了，怎麼辦？"},{"content":"（本文同步更新在 vocus 和 medium 上）\n嗨大家好，我是結語 JYu。\n開始撰寫這個系列的時間是 2023 四月，也是我在好想工作室 backend camp 培訓的倒數一個月，想說可以分享一些心得，給對轉職為後端工程師的人參考。\n【好想工作室 — 後端 (backend Camp)培訓心得（一）：好想工作室簡介】：簡單介紹好想工作室。\n【好想工作室 — 後端 (backend Camp)培訓心得（二）：backend camp 在幹嘛】：會講後端培訓的點點滴滴。\n➡️【好想工作室 — 後端 (backend Camp)培訓心得（三）：我好想進來好想】：會給想進 backend camp 的一些建議。\n【好想工作室 — 後端 (backend Camp)培訓心得（四）：我快崩潰了，怎麼辦？】：會講學員的心態管理。\n【好想工作室 — 後端 (backend Camp)培訓心得（五）：這麼多東西，要怎麼學最有效率？】：會講學員的學習技巧。\n【好想工作室 — 後端 (backend Camp)培訓心得（六）：我好想要錢（找工作）】：會講我自己的求職心得。等我找到工作後（應該會）再寫\n本系列文章純以我的觀察和想法為出發點，不一定就是實際狀況，也不帶任何批判。\n如果覺得資訊對你有用的話，不妨按下方拍手鼓勵一下我喔！\n然後我都是想到什麼就寫什麼，難免會有沒有提及到的，如果你有任何疑問，歡迎寄信至 jk29666338@gmail.com 來詢問我。\n好，廢話都講完了，那就讓我們開始吧！\n你能繼續看到這篇文章，應該是對後端培訓真的產生一點興趣，甚至想要加入 backend camp了吧。\n這篇文章就是寫給你的，最底下會有 backend camp 的招生文，歡迎自行服用。\n在開始正文之前，大家可以先想一件事：工作室最怕什麼？\n換個說法，在做人才培訓的單位，最害怕什麼？\n通常在做人才培訓的單位，都會有所謂的篩選機制。因為空間和人力真的有限，所以需要挑選最合適的人選。\n而最合適是如何定義的？我認為就是「不會輕易放棄」，試想一個人才培訓單位，只提供了三個名額，結果其中兩個第一個月就閃人，對於工作室來說，是空間浪費了；對於沒上的候選人來說，你讓他失去了一個轉職的機會。\n所以，與其說如何「通過」面談，倒不如問你自己會不會輕易放棄。\n有了這個基礎概念之後，我們再來看看可以如何準備吧。\n蒐集資訊 這個其實非常籠統，如果你能找到這篇文章也算你有蒐集資訊了吧：）\n這裡的蒐集資訊，包含但不限於：\n了解前端、後端的不同 了解工程師的起薪 了解南北部工程師求職環境 了解工程師的職涯規劃 了解工程師常用的工具 了解工作室的氛圍、培訓方式 直接來好想工作室，跟 camp 裡面的人聊聊 因為對於程式初學者來說，其實後端是相對 hardcore，如果你沒先好好了解，就貿然踏入後端的世界，很有可能會放棄。\n也有些人對於工程師有過於美好的幻想，以為在這邊培訓這六個月，出去之後就是炙手可熱的人才，年薪第一年就破百。\n反正你必須要對軟體工程師的世界有個大概的了解，無論是看影片、看文章、問人都可以。\n動手吧！ 要知道自己容不容易放棄，最快的方式就是動手做。\n同時，動手做也能展現你是一個有**「行動力」**的人。\n至於要做什麼、做的好不好，其實沒這麼重要。\n如果真的要建議的話，可以做一個簡單、可以連接資料庫的網站試試看。\n你可以挑一個教學影片、文章，然後自己嘗試實作。\n雖然你面試的時候應該會被說「阿你只會看著影片做這樣不行喔」，但至少能展現你對於軟體工程師實際上在幹嘛不是只有想像而已。\n第二層思考 在面談或寫申請問題的過程中，千萬不要急著回答問題，嘗試去思考問題背後有沒有其他的涵義。\n像我在面試的時候就不只一次跟 SoJ 說：「我思考一下。」\n當你說出這句的時候，不只是告訴對方給你一點點時間，同時也是展現你對這個問題的重視，你不願意隨便說出一個回答。\n在面談的過程中，如果真的有不知道的問題，也不要直接回答不知道。先設法做一些推論和假設，然後再詢問 SoJ 的意見。這個跟寫程式的時候一樣，當你放棄思考的時候，你一輩子都不可能解出 bug 了，但只要你還保持思考，你總有一天會解出 bug ，而且會愈解愈快。\n基本上我個人的建議就是只有這三個，加入 backend camp 就是如此輕鬆又寫意。\n不過對於一般人來說，要執行好這三項可能就要花一個月以上了 XD\n順帶一提，SoJ 真的是我遇過的所有面試官裡面，說話最實在的。他問完問題會說他為什麼要問？工作室在考量什麼？而且也會語重心長的說後端不好混喔XD\n下面附上招生文，有興趣加入 backend camp 的歡迎去聯絡 SoJ～\nttps://soj0825.github.io/2023/03/27/goodideas-backend-camp-11th/\n下一篇：【好想工作室 — 後端 (backend Camp)培訓心得（四）：我快崩潰了，怎麼辦？】：會講學員的心態管理。\n","date":"2023-05-18T19:18:09+08:00","image":"https://jyu1999.com/post/goodidea-mind-3/4_hu4e44a9238dd9439c985217ad54ea95d7_57691_120x120_fill_box_smart1_3.png","permalink":"https://jyu1999.com/post/goodidea-mind-3/","title":"好想工作室 — 後端 (Backend Camp) 培訓心得（三）：我好想進來好想"},{"content":"（本文同步更新在 vocus 和 medium 上）\n嗨大家好，我是結語 JYu。\n開始撰寫這個系列的時間是 2023 四月，也是我在好想工作室 backend camp 培訓的倒數一個月，想說可以分享一些心得，給對轉職為後端工程師的人參考。\n【好想工作室 — 後端 (backend Camp)培訓心得（一）：好想工作室簡介】：簡單介紹好想工作室。\n➡️【好想工作室 — 後端 (backend Camp)培訓心得（二）：backend camp 在幹嘛】：會講後端培訓的點點滴滴。\n【好想工作室 — 後端 (backend Camp)培訓心得（三）：我好想進來好想】：會給想進 backend camp 的一些建議。\n【好想工作室 — 後端 (backend Camp)培訓心得（四）：我快崩潰了，怎麼辦？】：會講學員的心態管理。\n【好想工作室 — 後端 (backend Camp)培訓心得（五）：這麼多東西，要怎麼學最有效率？】：會講學員的學習技巧。\n【好想工作室 — 後端 (backend Camp)培訓心得（六）：我好想要錢（找工作）】：會講我自己的求職心得。等我找到工作後（應該會）再寫\n本系列文章純以我的觀察和想法為出發點，不一定就是實際狀況，也不帶任何批判。\n如果覺得資訊對你有用的話，不妨按下方拍手鼓勵一下我喔！\n然後我都是想到什麼就寫什麼，難免會有沒有提及到的，如果你有任何疑問，歡迎寄信至 jk29666338@gmail.com 來詢問我。\n好，廢話都講完了，那就讓我們開始吧！\n我的夥伴們 進到工作室後，首抽就是跟你同 camp 的戰友。\n可別小看這群夥伴，在你解一個 bug 解一天還解不出來、做一個作業做一個月還做不完的時候，有人陪你一起耍蠢(X) 試錯(O) 其實是很重要的事情。\n在我們這屆，成員橫跨 20 出頭歲的菜鳥大學生，到 40 幾歲小孩已經上國中的父親。這些人不約而同的聚集在這裡，目的都只有一個：成為後端工程師。這就是所謂的共時性（X\n這群戰友們或多或少都有受過社會的洗禮，知道自己要的是什麼。而且可以很明顯的感覺到，有些人是抱持著「這是我人生中最後一次任性的決定」而出現在這裡的。\n不像高中大學的學生，眼前還有很多道路去給他們慢慢探索。這些人的目標非常純粹，因此，做起事來就是不遺餘力。常常看到有人半夜、假日還在線上，在解決程式問題。\n我一直都很佩服我這些同儕們，也從他們身上學到很多東西。雖然這樣講有點肉麻，但能跟他們一起培訓，真的是我這六個月覺得最幸運也最幸福的事情。（寫到這邊突然開始眼框泛淚…\n我的 mentor SoJ 大大是目前後端的 mentor，SoJ 其實不常出現在工作室，但也是 Backend Camp 的靈魂人物之一。\n首先說說他的管理風格好了，基本上是什麼都不管。這六個月我有印象的只有三個作業吧。他本人出現的次數也是很少。\n說他什麼都不管其實不是在臭他，他也不是真的對我們漠不關心。相反，無論我們問他什麼，他總是用最快的速度回答，而且有問必答，不厭其煩。\n我非常非常喜歡他的管理風格，我認為這樣才是真正符合自學的精神。據我所知其他 camp 的規定就稍微比較嚴格，作業也相對多，非常的不適合我。\n培訓的日子怎麼過的？從微觀到巨觀 我想要用 天 → 週 → 月 的順序，來說說我的後端培訓之旅。\n天 基本上每天早上八點到十點半之間要進到工作室，下午五點到八點之間離開。能待多久，全看個人狀況決定，mentor 主要會看你的學習成果來判斷你是否認真學習，而不是時數。\n當然也是不建議特立獨行，什麼半夜來中午走之類的。我個人在前期通常都會在 10 點多到，後期因為睡覺時間開始不受控制，有時候會看日出…所以可能 11 點多才會到。我通常是在晚上六七點走。\n每天到這邊之後就是打開電腦，自己想一下現在要學什麼，就開始進行。如果真的很悶，也可以起來看看其他同儕在幹嘛，請他們跟你分享，彼此交流意見。這個方法除了可以讓你很快跟別人混熟之外，因為每個人研究的面向都不一樣，你或許能從其他人的學習之中，得到一些新的靈感或想法。\n真的遇到問題，可以去找進駐者、mentor 或和同儕討論都可以。我自己蠻推薦大家先跟同儕討論的，就算同儕不會，至少你們能一起找尋資料，這個過程其實也可以讓你觀察其他人是怎麼解決問題的，然後設法把好的學習起來。直接找進駐者或 mentor 的話當然也可以，但是你就少了「找尋答案」的過程，我認為會比較可惜。\n因此，我自己的判斷基準是，如果一個 bug 卡了超過半小時，然後同儕討論都無解，我才會去問 mentor。\n同樣，如果你的同儕來問你問題，我個人建議完全不要藏私，也不要因為忙就推辭掉，因為這是一個很好的學習機會。\n著名的諾貝爾物理學獎得主 Richard Feynman 曾說過：\n如果你不能向其他人簡單地解釋一件事，那麼你就是還沒有真正弄懂它。\n當其他人來問你問題的時候，你可以試著解釋你的理解。然後你就會驚奇的發現，在解釋的過程中，你其實有些地方講的並不清楚，就更知道自己哪裡需要加強。\n為什麼我會這麼清楚這件事情呢？因為我畢竟算有資訊背景，比其他人提早開始寫程式，對於程式的理解也比較深。所以在前四個月大家研究的東西還差不多的時候，大家有問題都會來問我。\n其實如果可以的話，最好要能「主動分享」，你可以在聊天室裡面說你今天學了什麼，試著跟大家解釋你的所學。如果主題較多的話，你也可以直接召開會議。像我就有做簡報跟後端的學員講解物件導向、演算法、時間複雜度等等。\n週 每週一到五都是要出現的，當然臨時有事可以跟 mentor 請假。\n六日的話，想來也可以來。\n每週四會有一個活動「想知道嗎？」，開放工作室所有人，可以上台做一些分享，內容不拘。也沒有強迫觀眾一定要聽，反正不想聽的耳機掛著做自己的事情就好。\n說到每週固定活動，我自己有參與一個「Javascript 讀書會」。\n這個讀書會的起源也蠻奇妙的，就是一個某一位前端培訓（Frontend Camp）的成員一起被安排去倒垃圾，無意間她跟我提到的。我一聽就覺得蠻有興趣的，畢竟 JS 算是這幾天最火熱的語言沒有之一。\n讀書會的形式也類似於想知道嗎，反正就是挑自己有興趣的 JS 主題進行分享，如果有什麼專案也可以拿出來講。在這個過程中，也可以聽到前端是怎麼思考的，我自己是受益良多。\n所以我也蠻鼓勵大家不只是認識自己 camp 的成員們，也多去跟其他 camp 的人聊聊天，認識一下，甚至一起做事。畢竟後端以後大概率就是會需要跟前端合作嘛XD\n月 上一篇文章有提到，我比其他 camp 成員慢一個月進來。\n據他們所說，他們那個月基本上都在練英文打字、學習安裝環境和版本管理。\n打字速度對於工程師來說頗重要的，不只是在寫程式，有時候下一些指令、去網路上找資料也是要用英文找。我們主要是使用 ratatype 來練習，有興趣的可以去測一下自己的英打速度XD\n不過我的狀況算比較特殊，我英打本來就比較快，正常打文章就有 5X/wpm，如果是寫程式的話更快。安裝環境我是在進去之前，mentor 就告訴我可以先裝，所以我在週末就先裝好了。而版本管理也是之前在學校有稍微用過。\n再來第二個月會開始學習後端程式語言的語法，我們是使用 PHP。除此之外也會接觸到用來操作資料庫的語法 SQL。\n在這邊就是痛苦的開始了，你會遇到數不清的 bug，和想破頭都想不出來的問題。\n其實後面在學什麼已經沒這麼重要了，因為隨著大家摸索的愈來愈多，想學的東西也會逐漸出現分歧。\n所以在這裡我想來著重提一個概念：解決問題。\n解決問題 培訓六個月，不會讓你變成強者，但至少會讓你能「解決問題」。\n這是我在面試 backend camp 的時候，SoJ 跟我說的話。\n而我也非常認同。\n六個月的期間，從一開始，你的 bug 會多到根本不知道從何問起，不懂的地方就算別人講完你可能也聽不懂。\n到後來，你開始會慢慢可以組織問題，至少知道要怎麼樣去問別人。這時候別人有可能會給你一個非常重要的東西：「關鍵字」。\n接著，隨著你的「關鍵字」愈來愈多，你開始能自己上網 google 找到解答。但你卻不一定看得懂。\n之後，你開始能看懂解答到底在說什麼，你也有能力把問題描述清楚了。\n最後，也是最理想的狀態：當你遇到一個問題時，你能做出多種不同的推論。並把這些推論拆解成一個一個關鍵字，然後利用這些關鍵字上網搜尋，很快的找到答案並解決問題。\n當你到達最後一個階段的時候，我個人認為你已經可以說自己是一個 junior 的後端工程師了。\n「解決問題」事實上非常難以量化，卻是一個工程師最基礎的能力。\n「解決問題」聽起來也非常簡單，背後卻需要很多很多的努力。\n為了要解決問題，你必須要有足夠的基礎知識，否則根本不知道如何下關鍵字，也不知道錯在哪。\n為了要解決問題，你必須要有一定的英文閱讀能力，才不會 error message 看不懂，網路文章也看不懂。\n為了要解決問題，你必須要善用工具，無論是 chatgpt，或是其他的偵錯工具，幫助你知道問題在哪裡。\n為了要解決問題，你必須要會拆解問題，有些問題範圍太大、環環相扣，是難以找到解答的。\n為了要解決問題，你必須要放下面子，有時候趕快承認自己不會，不齒下問，會幫助你省下很多時間。\n學習是快樂的 最後，我想在這裡特別提這件事情。\n或許是台灣的教育環境所導致吧，我們說「學習」常常就會想到挑燈夜戰或懸樑刺股之類的成語，好像學習是一件非常刻苦的事情。\n工作室有些人也是抱持著這樣的想法，為了學寫程式，拋棄了生活中很多東西，想辦法把全部時間都投資在寫程式上面。\n我自己是對這些人感到佩服，但除非走投無路，不然我絕對不會採取這樣的作法。\n學習，尤其是對於軟體工程師來說，是一輩子的事情。而一件事要做一輩子，你要熱愛這件事情，也要能 Strike the balance between work and play。\n不僅如果你總是把自己逼的很緊，學習的效率會不好，而且當你遇到困難時，你有很大的機率會堅持不住。\n在寫程式這條路上，我有好幾次就是在電腦前從早坐到晚，從禮拜一坐到禮拜天，解不出來就是解不出來。然後就會開始想要放棄、開始擺爛。\n當然，我也不是鼓勵大家隨便學學。你還是要保有基本的學習態度，但在學程式之餘也別忘了多享受一下生活喔 : )\n如果對心態管理有興趣的，我會在第四篇的時候提及。\n下一篇：【好想工作室 — 後端 (backend Camp)培訓心得（三）：我好想進來好想】：會給想進 backend camp 的一些建議。\n","date":"2023-05-18T19:07:31+08:00","image":"https://jyu1999.com/post/goodidea-mind-2/4_hu4e44a9238dd9439c985217ad54ea95d7_57691_120x120_fill_box_smart1_3.png","permalink":"https://jyu1999.com/post/goodidea-mind-2/","title":"好想工作室 — 後端 (Backend Camp) 培訓心得（二）：backend camp 在幹嘛"},{"content":"（本文同步更新在 vocus 和 medium 上）\n前言 嗨大家好，我是結語 JYu。\n開始撰寫這個系列的時間是 2023 四月，也是我在好想工作室 backend camp 培訓的倒數一個月，想說可以分享一些心得，給對轉職為後端工程師的人參考。\n➡️【好想工作室 — 後端 (backend Camp)培訓心得（一）：好想工作室簡介】：簡單介紹好想工作室。\n【好想工作室 — 後端 (backend Camp)培訓心得（二）：backend camp 在幹嘛】：會講後端培訓的點點滴滴。\n【好想工作室 — 後端 (backend Camp)培訓心得（三）：我好想進來好想】：會給想進 backend camp 的一些建議。\n【好想工作室 — 後端 (backend Camp)培訓心得（四）：我快崩潰了，怎麼辦？】：會講學員的心態管理。\n【好想工作室 — 後端 (backend Camp)培訓心得（五）：這麼多東西，要怎麼學最有效率？】：會講學員的學習技巧。\n【好想工作室 — 後端 (backend Camp)培訓心得（六）：我好想要錢（找工作）】：會講我自己的求職心得。等我找到工作後（應該會）再寫\n本系列文章純以我的觀察和想法為出發點，不一定就是實際狀況，也不帶任何批判。\n如果覺得資訊對你有用的話，不妨按下方拍手鼓勵一下我喔！\n然後我都是想到什麼就寫什麼，難免會有沒有提及到的，如果你有任何疑問，歡迎寄信至 jk29666338@gmail.com 來詢問我。\n好，廢話都講完了，那就讓我們開始吧！\n好想工作室？ 如果你是透過搜尋而找到這篇文章，想必你早已知道好想工作室在幹嘛了，但這裡我還是快速說明一下。\n好想工作室是一個「資訊聚落」，目前位於台南火車站旁。\n裡面主要存在三種人，一種是「進駐者」，意指那些有著全職資訊相關工作的人。他們付費租借了一個工作室的位置，在工作室裡面工作。\n第二種人是「學員」，學員是指那些想要成為軟體工程師，正在全職進行培訓的人。\n第三種是「mentor」，就是引導學員學習的天使們XD\n這樣說的話，好想工作室有點類似一個，co-working space 和 教育機構的綜合體，不過只限定資訊領域，因此，我才會說他是一個「資訊聚落」。\n軟體工程師培訓？ 好想工作室非常佛心的提供了免費的軟體工程師培訓，根據專業不同，分為四個 camp：\n前端：主要負責一個網頁中你看得到的部分。 後端：主要負責一個網頁的後台。 Android：寫 android 手機的 app IOS：寫 IOS 系統的 app 每次培訓會是六個月，在這六個月的期間完全免費。在這六個月當中你必須在好想工作室裡面全職自學。\n但資訊領域博大精深，如果六個月學不完也不用擔心，如果學習態度良好，可以跟 mentor 討論成為「付費學員」，繼續在好想工作室學習。\n自學？ 初來乍到的人也許會想：「我看其他的培訓營都有課綱、都有老師上課，自學真的學的會嗎？」\n其實我從小到大的學習歷程就很討厭一句話：\n你就先學，總有一天你會用到的。\n在現代社會中，我們光是學「會用到的東西」，就算拼進全力也未必學的完了，更何況是去學「總有一天」會用到的東西。\n而自學的好處就在此，沒人告訴你要學什麼，也意味著你能挑真正對你有用的東西來學。\n沒有老師上課，在網路世界早已不是一個理由。除非領域真的特別偏門或新穎，不然以軟體工程師來說，youtube 隨便一個程式語言，可能就有幾百個課程，等於你實質上有幾百個老師可以教你。\n如果你需要作業，也有人針對語言設計了互動式的網頁和題目可以給你練習，甚至你可以直接請 chatgpt 幫忙出作業。\n可能又有人會問：「那我怎麼知道哪些東西重要？」\n但我認為「找重點」的能力本來就是一個軟體工程師必備的技能。就像我們寫程式 debug 的時候會需要分析錯誤，再設法解決。對自己也是一樣，身為軟體工程師，我們也要時時刻刻分析自己，看見自己的不足，而這些「不足」就是我們需要學習的重點。\n至於要怎麼分析？要怎麼針對自己的不足逐一改善？我在後面的文章也許會提。\n總而言之，自學是一個軟體工程師的必備技能，而如果能在工作前就能鍛鍊這個技能，不香嗎？\n我怎麼會在好想工作室？ 因為我的背景也和之後培訓的過程息息相關，因此在這裡我想先提我是怎麼入教的。\n2022 年我大學畢業之後，想找後端工程師的工作。但由於我不是純資訊科系出生的，在學校只有修過少少、不到三十學分資工系的課。於是我便告訴自己，要利用畢業後這一年，好好學習後端相關技能。\n一開始我是在 udemy 找課程，學習全端。但學沒多久我就發現效果不佳，不是因為內容太難我不會，而是缺乏別人可以討論和交流。當時的我對前後端都一無所知，也還不知道網路上大概有哪些資源可以善用。\n於是我開始尋找資訊培訓的機會，一開始是找到台北的 Appworks School，但沒有錄取。後來在入伍前一個禮拜，我赫然發現台南也有人在做資訊培訓，身為台南人的我狂喜。但猛一看早已超過報名期限。\n軍中的五天，我思索之後決定嘗試直接到好想工作室成為「進駐者」，等於是把好想工作室當 K 書中心的概念XD\n實際跟工作室的人見面之後，她告訴我要成為進駐者必須要有資訊相關工作，建議我可以先從學員開始，並鼓勵我寄信去問問看 mentor。\n後來我跟 mentor 聊過之後，他認為我三觀還算端正，也算願意學習，就讓我加入了 backend camp。\n於是，我比後端 camp 的其他成員晚一個月開始培訓，也要比大家晚一個月走QQ\n培訓的辛酸血淚史也從這邊開始了…\n下一篇：【好想工作室 — 後端 (backend Camp)培訓心得（二）：backend camp 在幹嘛】：會講後端培訓的點點滴滴。\n","date":"2023-05-18T16:34:03+08:00","image":"https://jyu1999.com/post/goodidea-mind-1/4_hu4e44a9238dd9439c985217ad54ea95d7_57691_120x120_fill_box_smart1_3.png","permalink":"https://jyu1999.com/post/goodidea-mind-1/","title":"好想工作室 — 後端 (Backend Camp) 培訓心得（一）：好想工作室簡介"}]